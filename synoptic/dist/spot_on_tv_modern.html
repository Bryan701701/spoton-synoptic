<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spot On – Modern</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="preconnect" href="https://cdn.plot.ly" crossorigin>
    <link rel="dns-prefetch" href="https://cdn.plot.ly">



  <style>


    :root{
    --bg:#ffffff; --ink:#111827; --muted:#6b7280; --panel:#f3f4f6;
    --ring:#e5e7eb; --card:#ffffff; --radius:14px; --shadow:0 6px 20px rgba(0,0,0,.06);

    /* NEW: layout vars */
    --shell-pad: clamp(12px,2vw,20px);
    --headerH: 64px;          /* updated by JS below on load/resize */
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
    margin:0; background:var(--bg); color:var(--ink);
    font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif;
    }

    /* Page shell — make it fluid */
    .page{
    max-width: none;
    width: 100%;
    margin: 0 auto;
    padding: var(--shell-pad);          /* ← use your var */
    display:flex; flex-direction:column; gap:18px;
    }

    /* Header (unchanged visuals) */
    .header{
    display:flex; align-items:center; justify-content:space-between;
    gap:16px; padding:10px 14px;
    background:var(--card); border:1px solid var(--ring);
    border-radius:var(--radius); box-shadow:var(--shadow);
    }
    .brand{ font-weight:800; letter-spacing:.2px }
    .meta{ display:flex; align-items:center; gap:14px; color:var(--muted); font-weight:600 }

    /* Map block — fill viewport height beneath header */
    /* Fallback */
    .map-wrap{
    width:100%;
    height: calc(100vh - var(--headerH) - var(--shell-pad)*2);
    display:flex; position:relative; isolation:isolate;
    }

    /* Prefer dynamic viewport when supported */
    @supports (height: 100dvh){
    .map-wrap{
        height: calc(100dvh - var(--headerH) - var(--shell-pad)*2);
    }
    }

    #tv-map{
    flex:1;
    width:100%;
    height:100%;
    display:block;
    border:0;
    position:relative;
    z-index:1;
    }

    /* Floating dial panel */
    .dials-float{
    position:absolute; top:8%; left:6%;
    /* Use a default width, but allow JS/user to override it */
    width: var(--dials-w, 340px);
    min-width: 200px;
    max-width: 700px;
    height: var(--dials-h, auto);
    max-height: min(82vh, 82dvh);
    overflow: auto;
    background: var(--card);
    border:1px solid var(--ring);
    border-radius:12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.15);
    z-index:25;
    }












    /* let the whole floating box be a column */
    .forecast-float{
    position:absolute; top:8%; right:6%;
    width: var(--forecast-w, 560px);
    min-width: 200px;
    max-width: 1100px;
    height: var(--forecast-h, auto);
    max-height: min(82vh, 82dvh);
    background: var(--card);
    border:1px solid var(--ring);
    border-radius:12px;
    box-shadow: var(--shadow);
    z-index:25;

    display:flex;
    flex-direction:column;
    overflow:hidden;                 /* outer doesn’t scroll */
    }















    /* --- resizable panel handle --- */
    .resizable { position: relative; }

    .resize-handle {
    position: absolute;
    right: 6px; bottom: 6px;
    width: 16px; height: 16px;
    z-index: 5;
    border: 1px solid var(--ring);
    border-radius: 4px;
    background: #fff;
    box-shadow: 0 1px 2px rgba(0,0,0,.08);
    cursor: nwse-resize;
    opacity: .85;
    }
    .resize-handle::after {
    content: "";
    position: absolute;
    right: 3px; bottom: 3px;
    width: 8px; height: 8px;
    border-right: 2px solid #c4c7cf;
    border-bottom: 2px solid #c4c7cf;
    transform: translate(0,0);
    }

    /* Keep the handle above scrolling inner content */
    #dials .resize-handle,
    #forecast-float .resize-handle { position: absolute; right: 6px; bottom: 6px; z-index: 5; }






    /* Drag handle (so normal map interactions still work) */
    .dials-handle{
    cursor: move;
    background: #f8f9fb;
    border-bottom: 1px solid var(--ring);
    padding: 8px 10px;
    display:flex; align-items:center; justify-content:space-between;
    font-weight:700; font-size: 13px; color:var(--muted);
    }

    /* Status chip shows green/amber/red */
    .state-chip{
    display:inline-flex; align-items:center; gap:6px;
    padding: 4px 8px; border-radius: 999px; font-weight:700; font-size:12px;
    background:#f3f4f6; color:#111;
    }
    .state-chip::before{
    content:""; width:8px; height:8px; border-radius:50%;
    background:#bbb;
    }
    .dials-float.state-green .state-chip::before{ background:#22c55e; }
    .dials-float.state-amber .state-chip::before{ background:#f59e0b; }
    .dials-float.state-red   .state-chip::before{ background:#ef4444; }

    .dials-float.state-green #dual-dial > circle { stroke: rgba(34,197,94,.55); stroke-width:4; }
    .dials-float.state-amber #dual-dial > circle { stroke: rgba(245,158,11,.55); stroke-width:4; }
    .dials-float.state-red   #dual-dial > circle { stroke: rgba(239,68,68,.55); stroke-width:4; }



    /* Compact dials */
    .dials-body{ padding:10px; display:grid; gap:10px; }
    .dials-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }




    .read-row{
    display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; margin-top:6px;
    }
    .read{
    background:var(--panel); border:1px solid var(--ring);
    border-radius:8px; padding:8px 10px; display:flex; gap:6px; align-items:baseline;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .read label{font-size:11px; color:var(--muted); font-weight:700}
    .read strong{font-size:18px}










    /* Controls under map */
    .controls{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding:10px 12px;
      background:var(--card); border:1px solid var(--ring);
      border-radius:var(--radius); box-shadow: var(--shadow);
    }
    .day-buttons{display:flex; gap:8px; flex-wrap:wrap}
    .day-buttons button, .zoom-buttons button, #forecast-toggle{
      border:1px solid var(--ring); background:#fafafa; color:var(--ink);
      padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700;
    }
    .day-buttons button:hover, .zoom-buttons button:hover, #forecast-toggle:hover{
      background:#f5f5f5;
    }
    .zoom-buttons{display:flex; gap:8px; align-items:center}

    /* Dials + readouts grid */

    .panel h3{margin:0 0 10px 0; font-size:14px; color:var(--muted); letter-spacing:.4px}

    /* Dial cards left/right */

    .dial {
    border: none;     /* remove the outer circle */
    }

    /* Readouts row */
    .readouts{grid-column: span 12; display:grid; grid-template-columns: repeat(3, 1fr); gap:12px}
    .readout{
      background:var(--panel); border:1px solid var(--ring);
      border-radius: 10px; padding:10px 14px;
      display:flex; align-items:baseline; gap:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .readout label{font-size:12px; color:var(--muted); font-weight:700}
    .readout strong{font-size:20px}

    /* Forecast dropdown */
    .forecast{grid-column: span 12}
    #forecast-panel{
      margin-top:8px; border:1px solid var(--ring); background:var(--card);
      border-radius:10px; padding:12px; max-height:0; overflow:hidden; transition:max-height .25s ease;
      white-space:pre-wrap; font-family: ui-monospace, monospace; line-height:1.35;
    }
    #forecast-panel.open{ max-height: 60vh; overflow:auto; }

    /* Responsive tweaks */
    @media (max-width: 900px){
      .dial-card{grid-column: span 12}
      .readouts{grid-template-columns:1fr}
    }

    /* Top toolbar */
    .toolbar{
    display:flex; align-items:center; justify-content:space-between;
    gap:12px; flex-wrap:wrap;               /* wraps to 2 rows on small screens */
    padding:10px 12px;
    background:var(--card); border:1px solid var(--ring);
    border-radius:var(--radius); box-shadow:var(--shadow);
    }

    .group{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .btn{
    border:1px solid var(--ring); background:#fafafa; color:var(--ink);
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700;
    }
    .btn:hover{ background:#f5f5f5; }



    /* colors for mapping wind vs swell */
    :root{
    --wind-accent: #D8A55A;      /* sandy */
    --swell-accent:#1E68FF;      /* blue  */
    }

    /* The wrapper around the SVG must also stretch */
    .dial--svg{
    width: 100%;
    padding: 6px 10px;          /* you already have this — keep it */
    display:flex; align-items:center; justify-content:center;
    }

    .chev path{
    fill:none;
    stroke-width:6;
    stroke-linecap:square;
    stroke-linejoin:miter;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,.12));
    }

    .chev--wind  path{ stroke: var(--wind-accent); }
    .chev--swell path{ stroke: var(--swell-accent); }

    /* color key dots in readouts */

    /* keep your existing bits … */
    .readouts--inline{
        grid-template-columns: repeat(3, minmax(0,1fr));
        gap: 8px;
        padding-inline: 8px;   /* ← new: same space at the row edges as between cards */
        margin-top: 10px;
    }

    .readout{ display:flex; align-items:baseline; gap:8px; background:var(--panel); border:1px solid var(--ring); border-radius:10px; padding:8px 12px; }
    .readout label{ font-size:12px; color:var(--muted); font-weight:700; }
    .readout strong{ font-size:16px; }
    .readout{ flex-direction: column; align-items: center; padding: 8px 10px; }
    .readout label{
    display: inline-flex; align-items: center; gap: 6px;
    white-space: nowrap; font-size: 11px; letter-spacing: .02em;
    }

    .chev-mini{ width:14px; height:14px; flex:0 0 14px; }
    .chev-mini path{
    fill:none; stroke-width:3; stroke-linecap:square; stroke-linejoin:miter;
    }
    .chev-mini--wind  path{ stroke: var(--wind-accent); }
    .chev-mini--swell path{ stroke: var(--swell-accent); }

    /* Smooth rotation */
    .chev-mini{ transform-origin: 50% 50%; transition: transform .15s ease; }



    /* make the HUD a bit wider and centre the dial */
    .hud{ width: 100%;}

    /* Make the dial container span the panel’s width */
    .hud-body{
    width: 100%;
    }





    /* Make each readout a vertical two-line stack */
    .readouts--inline{
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 10px;
    }

    .readout{
    flex-direction: column;        /* 2 lines */
    align-items: center;
    padding: 8px 10px;             /* tighter */
    min-width: 0;                  /* prevents “growing” past the grid cell */
    }

    .readout label{
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;           /* keep dot + word on one line */
    font-size: 11px;
    letter-spacing: .02em;
    }

    .readout strong{
    font-size: 16px;               /* a bit smaller = shorter cards */
    line-height: 1.1;
    white-space: nowrap;           /* “ESE 24 mph” stays on one line */
    }

    /* header line inside the floating panel */
    .dials-handle{
    white-space: nowrap;
    gap: 10px;
    }
    #hud-title{
    overflow: hidden;           /* long spot names clip nicely */
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 70%;
    }
    .state-chip{ flex: 0 0 auto; } /* don't let it shrink/wrap */


    .chip{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px; border-radius:999px; border:1px solid var(--ring);
    font-weight:700; font-size:13px; line-height:1; background:var(--card); color:var(--ink);
    box-shadow: var(--shadow);
    }
    .chip-plain{ background:#fafafa; }
    .chip-action{ cursor:pointer; }
    .chip-action:hover{ background:#f5f5f5; }


    /* Forecast drawer */
    .forecast{
    border:1px solid var(--ring);
    background:var(--card);
    border-radius:12px;
    box-shadow: var(--shadow);
    overflow:hidden;
    }

    /* inner padding + layout */
    .forecast-inner{
    display:flex;
    flex-direction:column;
    flex:1;
    min-height:0;                    /* critical */
    }

    .forecast-tabs{
    display:flex; gap:8px; padding:10px; border-bottom:1px solid var(--ring);
    background:#fafafa;
    }
    .forecast-tabs .tab{
    appearance:none; border:1px solid var(--ring); background:#fff; color:var(--ink);
    padding:6px 10px; border-radius:9px; font-weight:700; cursor:pointer;
    }
    .forecast-tabs .tab[aria-selected="true"]{
    background:#eef2ff; border-color:#c7d2fe;
    }

    .region-forecast { margin-top: 8px; }

    .forecast-panels{
    padding:12px;
    flex:1;
    min-height:0;                    /* critical */
    overflow:auto;                   /* the content area scrolls */
    }

    .forecast-panel{
    margin:0;
    white-space:pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    line-height:1.35; font-size:14px; color:var(--ink);
    }

    /* show/hide via [hidden] attribute to keep ARIA happy */
    [hidden]{ display:none !important; }

    .forecast-header {
    font-weight: 700;
    margin: 8px 0 6px;
    }


    .forecast-handle{
    cursor:move; user-select:none;
    background:#f8f9fb;
    border-bottom:1px solid var(--ring);
    padding:8px 10px;
    display:flex; align-items:center; justify-content:space-between;
    font-weight:700; font-size:13px; color:var(--muted);
    }
    .close-x{
    appearance:none; border:1px solid var(--ring); background:#fff; cursor:pointer;
    border-radius:8px; padding:2px 8px; font-weight:800;
    }
    .close-x:hover{ background:#f5f5f5; }

    /* make it friendly on phones */
    @media (max-width: 900px){
    .forecast-float{
        left:4%; right:4%;
        width:auto;
        top:auto;
        bottom:calc(6% + env(safe-area-inset-bottom, 0));
    }
    .dials-float{
        left:4%; right:auto;
        width:clamp(200px, 70vw, 360px);
        top:6%;
    }
    }

    /* give the HUD a comfortable max width (optional) */
    .hud{ width:100%}

    /* Dial sizing — let it fill the dials panel */
    #dual-dial{
    display:block;
    width:100%;
    height:auto;
    max-width:none;            /* allow it to grow with the panel */
    }

    /* Base: center the SVG and shrink it by % on larger screens */
    :root { --dial-pct: 65%; }

    .dial--svg { display:flex; align-items:center; justify-content:center; }

    #dual-dial { width: 100%; height: auto; max-width: none; }    /* baseline */
    .dial--svg > #dual-dial { width: var(--dial-pct); }           /* shrink */

    /* Phones: let it fill the panel but cap the physical size */
    @media (max-width: 520px){
    .dial--svg > #dual-dial { width: 100%; }
    #dual-dial { max-width: 260px; }
    }

    /* readouts tidy */
    .readouts--inline{
    grid-template-columns: repeat(3, minmax(0,1fr));
    gap: 8px;
    }


    .tide-card{ width:100%; }                /* fill panel width */


    .tide-card svg{
    display:block;
    width:100%;
    height:auto;                /* let it grow with width */
    aspect-ratio: 320 / 84;     /* matches viewBox -> scales cleanly */
    }
    .tide-card{
    margin-top: 8px;
    background: var(--card);
    border: 1px solid var(--ring);
    border-radius: 12px;
    padding: 8px;
    }

    .tide-info-row{
    display:flex;
    align-items:center;
    gap:8px;
    margin-top:8px;
    }



    .tide--water{ fill: rgba(30,104,255,.10); stroke: rgba(30,104,255,.8); stroke-width:2; }
    .tide--axis  { stroke:#d7dbe2; stroke-width:1; }
    .tide--night { fill: rgba(17,24,39,.06); }
    .tide--markH { fill:#ef4444; }
    .tide--markL { fill:#111827; }
    .tide--label { font: 11px/1.1 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; fill: var(--muted); }


    .tide--tick      { stroke:#d7dbe2; stroke-width:1; }
    .tide--tickLabel { font:10px/1 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; fill: var(--muted); }
    .tide--past  { fill: rgba(30,104,255,.05); }


        /* best-window overlay (under the curve) */
    .tide--window { stroke: none; fill-opacity: .20; }
    .tide--window.green { fill: #22c55e; }  /* green */
    .tide--window.amber { fill: #f59e0b; }  /* amber */

    /* Bold vertical edges for best-window blocks */
    .tide--windowEdge { stroke-width: 2.5; opacity: .95; }
    .tide--windowEdge.green { stroke: #22c55e; }  /* match your green */
    .tide--windowEdge.amber { stroke: #f59e0b; }  /* match your amber */




    
    .view-hidden { display: none !important; }


    /* Shared stage height so map == synoptic */
    :root{
    --stageH: min(80vh, 80dvh);      /* same as synoptic stage */
    --leftW:  360px;                  /* default left pane width  */
    --rightW: 560px;                  /* default right pane width */
    }

    /* ===== SPLIT LAYOUT (desktop) ===== */
    body.layout-split .map-wrap{
    /* Turn the map region into a 3-column grid */
    display: grid;
    grid-template-columns: var(--leftW) 1fr var(--rightW);
    grid-template-areas: "left center right";
    gap: 12px;

    width: 100%;
    height: var(--stageH);
    padding: 0;
    background: transparent;
    border: none;
    }

    /* Pin elements to named areas */
    body.layout-split #dials{          grid-area: left;  }
    body.layout-split #tv-map{         grid-area: center;}
    body.layout-split #forecast-float{ grid-area: right; }

    /* Map fills its cell and matches card chrome */
    body.layout-split #tv-map{
    width: 100%;
    height: 100%;
    display: block;
    border: 1px solid var(--ring);
    border-radius: var(--radius);
    }

    /* Side panes become normal blocks (not absolute overlays) */
    body.layout-split .dials-float,
    body.layout-split .forecast-float{
    position: relative;
    top: auto; left: auto; right: auto; bottom: auto;
    width: auto; height: auto; max-height: 100%;
    overflow: auto;
    transform: none;
    box-shadow: var(--shadow);
    margin: 0;                         /* keep grid gutters consistent */
    }

    /* Hide resize handles in split mode (optional) */
    body.layout-split .resize-handle{ display: none; }

    /* Collapse columns when a panel is hidden */
    body.layout-split .map-wrap:has(#dials[hidden]){
    grid-template-columns: 0 1fr var(--rightW);
    }
    body.layout-split .map-wrap:has(#forecast-float[hidden]){
    grid-template-columns: var(--leftW) 1fr 0;
    }
    body.layout-split .map-wrap:has(#dials[hidden]):has(#forecast-float[hidden]){
    grid-template-columns: 0 1fr 0;
    }

    /* ===== FALLBACK TO OVERLAYS (tablets/phones) ===== */
    @media (max-width: 1100px){
    body.layout-split .map-wrap{
        display: block;  /* back to your absolute panels */
        height: calc(100vh - var(--headerH) - var(--shell-pad)*2);
    }
    @supports (height: 100dvh){
        body.layout-split .map-wrap{
        height: calc(100dvh - var(--headerH) - var(--shell-pad)*2);
        }
    }
    body.layout-split .dials-float,
    body.layout-split .forecast-float{
        position: absolute;  /* revert to floating overlays */
    }
    }

    /* Overlays only when NOT in split mode */
    body:not(.layout-split) .dials-float,
    body:not(.layout-split) .forecast-float {
    position: absolute;
    }

    /* In split mode they’re regular blocks (you already have this, but it’s fine to be explicit) */
    body.layout-split .dials-float,
    body.layout-split .forecast-float {
    position: relative;
    }

    #tv-map{ transition: opacity .24s ease; }


    /* Forecast summary inside the HUD */
    #whatsup-summary {
    margin-top: 0.75rem;       /* space above, separated from tide card */
    padding: 0.75rem 1rem;     /* inner breathing space */
    background: #f9fafb;       /* light background (same tone as tide card) */
    border: 1px solid #e5e7eb; /* subtle border */
    border-radius: 0.375rem;   /* rounded corners to match HUD elements */
    font-size: 0.875rem;       /* small but readable */
    line-height: 1.4;
    color: #374151;            /* slate grey for text */
    }

    /* Make “Best: …” call stand out */
    #whatsup-summary strong {
    color: #111827;            /* darker text */
    font-weight: 600;
    }

    .header .meta {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap; /* keeps it tidy on narrower widths */
    }

    /* Inline navigator container */
    .area-nav-inline {
    display: flex;
    gap: 6px;
    align-items: center;
    }

    /* Make the country/area selects match .chip look & feel */
    .area-nav-inline select{
    appearance: none;           /* keeps it neat, leaves native arrow on Safari/iOS */
    border: 1px solid var(--ring);
    background: var(--card);
    color: var(--ink);
    padding: 6px 10px;          /* same vertical rhythm as .chip */
    border-radius: 999px;       /* pill like .chip */
    font-weight: 700;           /* like .chip */
    font-size: 13px;            /* like .chip */
    line-height: 1;
    box-shadow: var(--shadow);  /* like .chip */
    cursor: pointer;
    height: auto;               /* let padding control height */
    }

    /* Hover & focus to mirror .chip-action */
    .area-nav-inline select:hover{
    background: #f5f5f5;
    }
    .area-nav-inline select:focus{
    outline: none;
    box-shadow: 0 0 0 2px #e5e7eb; /* subtle focus ring */
    }

    /* Disabled state (matches your chips’ tone) */
    .area-nav-inline select:disabled{
    opacity: .55;
    cursor: not-allowed;
    }

    /* Optional: keep dropdown options readable & bold-ish */
    .area-nav-inline select option{
    font-weight: 600;
    }

    .tide-info-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
    }

    #hud-title.chip {
    font-weight: 700;
    font-size: 13px;
    line-height: 1;
    background: #fafafa;
    border-radius: 999px;
    border: 1px solid var(--ring);
    padding: 6px 10px;
    box-shadow: var(--shadow);
    color: var(--ink);
    }

    /* keep pills readable even before options are populated */
    .area-nav-inline select {
      min-width: 120px;   /* add this */
    }


    /* Optional: on very narrow screens, hide continent/country first */
    @media (max-width: 760px) {
    #sel-cont, #sel-country { display: none; }
    }

  </style>

    <script>
    // Injected from Python/Jinja
    window.REGION_DATA = {
  "Cornwall": {
    "2026-01-01": {
      "wind_speed": 6.9,
      "wind_dir": 299,
      "swell_height": 0.8,
      "swell_dir": 257,
      "swell_period": 7.2
    },
    "2026-01-02": {
      "wind_speed": 9.5,
      "wind_dir": 316,
      "swell_height": 1.2,
      "swell_dir": 327,
      "swell_period": 5.3
    },
    "2026-01-03": {
      "wind_speed": 10.9,
      "wind_dir": 342,
      "swell_height": 1.7,
      "swell_dir": 346,
      "swell_period": 6.0
    }
  },
  "Gower": {
    "2026-01-01": {
      "wind_speed": 10.3,
      "wind_dir": 302,
      "swell_height": 0.7,
      "swell_dir": 266,
      "swell_period": 5.5
    },
    "2026-01-02": {
      "wind_speed": 13.8,
      "wind_dir": 303,
      "swell_height": 1.0,
      "swell_dir": 281,
      "swell_period": 4.8
    },
    "2026-01-03": {
      "wind_speed": 3.3,
      "wind_dir": 343,
      "swell_height": 1.1,
      "swell_dir": 316,
      "swell_period": 4.8
    }
  },
  "The North East": {
    "2026-01-01": {
      "wind_speed": 12.3,
      "wind_dir": 291,
      "swell_height": 1.0,
      "swell_dir": 334,
      "swell_period": 6.7
    },
    "2026-01-02": {
      "wind_speed": 7.1,
      "wind_dir": 286,
      "swell_height": 3.1,
      "swell_dir": 4,
      "swell_period": 10.2
    },
    "2026-01-03": {
      "wind_speed": 14.4,
      "wind_dir": 316,
      "swell_height": 2.9,
      "swell_dir": 5,
      "swell_period": 8.5
    }
  },
  "North Yorks": {
    "2026-01-01": {
      "wind_speed": 9.1,
      "wind_dir": 290,
      "swell_height": 1.3,
      "swell_dir": 332,
      "swell_period": 6.8
    },
    "2026-01-02": {
      "wind_speed": 14.6,
      "wind_dir": 303,
      "swell_height": 3.0,
      "swell_dir": 359,
      "swell_period": 10.3
    },
    "2026-01-03": {
      "wind_speed": 11.0,
      "wind_dir": 322,
      "swell_height": 4.0,
      "swell_dir": 353,
      "swell_period": 8.6
    }
  },
  "North Devon": {
    "2026-01-01": {
      "wind_speed": 10.5,
      "wind_dir": 301,
      "swell_height": 1.0,
      "swell_dir": 300,
      "swell_period": 4.7
    },
    "2026-01-02": {
      "wind_speed": 8.3,
      "wind_dir": 324,
      "swell_height": 1.3,
      "swell_dir": 312,
      "swell_period": 5.0
    },
    "2026-01-03": {
      "wind_speed": 10.4,
      "wind_dir": 331,
      "swell_height": 1.4,
      "swell_dir": 333,
      "swell_period": 5.0
    }
  },
  "Pembrokeshire": {
    "2026-01-01": {
      "wind_speed": 7.3,
      "wind_dir": 297,
      "swell_height": 0.8,
      "swell_dir": 286,
      "swell_period": 5.1
    },
    "2026-01-02": {
      "wind_speed": 8.6,
      "wind_dir": 309,
      "swell_height": 1.4,
      "swell_dir": 303,
      "swell_period": 5.2
    },
    "2026-01-03": {
      "wind_speed": 8.2,
      "wind_dir": 344,
      "swell_height": 1.3,
      "swell_dir": 322,
      "swell_period": 5.4
    }
  },
  "The East Coast": {
    "2026-01-01": {
      "wind_speed": 10.9,
      "wind_dir": 310,
      "swell_height": 1.3,
      "swell_dir": 324,
      "swell_period": 5.2
    },
    "2026-01-02": {
      "wind_speed": 9.8,
      "wind_dir": 337,
      "swell_height": 1.6,
      "swell_dir": 19,
      "swell_period": 8.7
    },
    "2026-01-03": {
      "wind_speed": 10.3,
      "wind_dir": 324,
      "swell_height": 1.5,
      "swell_dir": 14,
      "swell_period": 6.5
    }
  },
  "Moray": {
    "2026-01-01": {
      "wind_speed": 13.9,
      "wind_dir": 322,
      "swell_height": 2.9,
      "swell_dir": 338,
      "swell_period": 7.0
    },
    "2026-01-02": {
      "wind_speed": 12.1,
      "wind_dir": 57,
      "swell_height": 2.7,
      "swell_dir": 11,
      "swell_period": 8.3
    },
    "2026-01-03": {
      "wind_speed": 10.6,
      "wind_dir": 10,
      "swell_height": 3.1,
      "swell_dir": 7,
      "swell_period": 7.2
    }
  },
  "Caithness": {
    "2026-01-01": {
      "wind_speed": 14.6,
      "wind_dir": 333,
      "swell_height": 4.1,
      "swell_dir": 326,
      "swell_period": 8.2
    },
    "2026-01-02": {
      "wind_speed": 7.8,
      "wind_dir": 20,
      "swell_height": 3.0,
      "swell_dir": 2,
      "swell_period": 8.2
    },
    "2026-01-03": {
      "wind_speed": 17.0,
      "wind_dir": 348,
      "swell_height": 3.4,
      "swell_dir": 359,
      "swell_period": 7.5
    }
  },
  "Sutherland": {
    "2026-01-01": {
      "wind_speed": 15.6,
      "wind_dir": 331,
      "swell_height": 5.1,
      "swell_dir": 335,
      "swell_period": 10.3
    },
    "2026-01-02": {
      "wind_speed": 10.3,
      "wind_dir": 13,
      "swell_height": 5.1,
      "swell_dir": 354,
      "swell_period": 10.7
    },
    "2026-01-03": {
      "wind_speed": 16.5,
      "wind_dir": 357,
      "swell_height": 4.3,
      "swell_dir": 353,
      "swell_period": 9.7
    }
  },
  "Hebrides": {
    "2026-01-01": {
      "wind_speed": 13.2,
      "wind_dir": 330,
      "swell_height": 4.6,
      "swell_dir": 340,
      "swell_period": 10.0
    },
    "2026-01-02": {
      "wind_speed": 17.5,
      "wind_dir": 348,
      "swell_height": 4.5,
      "swell_dir": 359,
      "swell_period": 10.2
    },
    "2026-01-03": {
      "wind_speed": 14.4,
      "wind_dir": 353,
      "swell_height": 3.8,
      "swell_dir": 356,
      "swell_period": 9.4
    }
  },
  "Northwest Wales": {
    "2026-01-01": {
      "wind_speed": 9.0,
      "wind_dir": 290,
      "swell_height": 1.4,
      "swell_dir": 299,
      "swell_period": 4.7
    },
    "2026-01-02": {
      "wind_speed": 8.3,
      "wind_dir": 334,
      "swell_height": 1.7,
      "swell_dir": 312,
      "swell_period": 5.8
    },
    "2026-01-03": {
      "wind_speed": 5.1,
      "wind_dir": 8,
      "swell_height": 1.6,
      "swell_dir": 325,
      "swell_period": 5.5
    }
  },
  "South Devon": {
    "2026-01-01": {
      "wind_speed": 6.9,
      "wind_dir": 282,
      "swell_height": 0.5,
      "swell_dir": 266,
      "swell_period": 5.8
    },
    "2026-01-02": {
      "wind_speed": 6.0,
      "wind_dir": 321,
      "swell_height": 0.6,
      "swell_dir": 287,
      "swell_period": 4.8
    },
    "2026-01-03": {
      "wind_speed": 2.2,
      "wind_dir": 309,
      "swell_height": 0.7,
      "swell_dir": 260,
      "swell_period": 6.5
    }
  },
  "The West Coast": {
    "2026-01-01": {
      "wind_speed": 11.3,
      "wind_dir": 334,
      "swell_height": 2.7,
      "swell_dir": 320,
      "swell_period": 7.1
    },
    "2026-01-02": {
      "wind_speed": 9.4,
      "wind_dir": 352,
      "swell_height": 2.9,
      "swell_dir": 326,
      "swell_period": 7.2
    },
    "2026-01-03": {
      "wind_speed": 6.8,
      "wind_dir": 357,
      "swell_height": 2.6,
      "swell_dir": 326,
      "swell_period": 7.2
    }
  },
  "Causeway Coast": {
    "2026-01-01": {
      "wind_speed": 8.0,
      "wind_dir": 337,
      "swell_height": 3.0,
      "swell_dir": 331,
      "swell_period": 7.5
    },
    "2026-01-02": {
      "wind_speed": 12.9,
      "wind_dir": 340,
      "swell_height": 3.2,
      "swell_dir": 334,
      "swell_period": 7.6
    },
    "2026-01-03": {
      "wind_speed": 11.1,
      "wind_dir": 8,
      "swell_height": 3.0,
      "swell_dir": 337,
      "swell_period": 7.5
    }
  },
  "Donegal": {
    "2026-01-01": {
      "wind_speed": 5.5,
      "wind_dir": 351,
      "swell_height": 2.2,
      "swell_dir": 326,
      "swell_period": 7.4
    },
    "2026-01-02": {
      "wind_speed": 6.3,
      "wind_dir": 336,
      "swell_height": 2.2,
      "swell_dir": 323,
      "swell_period": 7.7
    },
    "2026-01-03": {
      "wind_speed": 10.6,
      "wind_dir": 360,
      "swell_height": 2.5,
      "swell_dir": 332,
      "swell_period": 7.8
    }
  },
  "County Sligo": {
    "2026-01-01": {
      "wind_speed": 4.3,
      "wind_dir": 345,
      "swell_height": 2.4,
      "swell_dir": 347,
      "swell_period": 8.1
    },
    "2026-01-02": {
      "wind_speed": 7.7,
      "wind_dir": 18,
      "swell_height": 3.3,
      "swell_dir": 353,
      "swell_period": 9.0
    },
    "2026-01-03": {
      "wind_speed": 10.9,
      "wind_dir": 352,
      "swell_height": 3.2,
      "swell_dir": 355,
      "swell_period": 8.7
    }
  },
  "County Clare": {
    "2026-01-01": {
      "wind_speed": 7.9,
      "wind_dir": 302,
      "swell_height": 0.8,
      "swell_dir": 291,
      "swell_period": 5.7
    },
    "2026-01-02": {
      "wind_speed": 8.3,
      "wind_dir": 326,
      "swell_height": 1.5,
      "swell_dir": 320,
      "swell_period": 6.1
    },
    "2026-01-03": {
      "wind_speed": 7.4,
      "wind_dir": 6,
      "swell_height": 1.0,
      "swell_dir": 320,
      "swell_period": 6.5
    }
  },
  "Dingle Peninsula": {
    "2026-01-01": {
      "wind_speed": 2.5,
      "wind_dir": 274,
      "swell_height": 1.0,
      "swell_dir": 283,
      "swell_period": 9.2
    },
    "2026-01-02": {
      "wind_speed": 8.8,
      "wind_dir": 332,
      "swell_height": 2.5,
      "swell_dir": 347,
      "swell_period": 8.9
    },
    "2026-01-03": {
      "wind_speed": 10.0,
      "wind_dir": 14,
      "swell_height": 2.3,
      "swell_dir": 350,
      "swell_period": 8.2
    }
  },
  "The South": {
    "2026-01-01": {
      "wind_speed": 7.4,
      "wind_dir": 297,
      "swell_height": 0.7,
      "swell_dir": 170,
      "swell_period": 6.6
    },
    "2026-01-02": {
      "wind_speed": 3.9,
      "wind_dir": 290,
      "swell_height": 0.3,
      "swell_dir": 194,
      "swell_period": 5.5
    },
    "2026-01-03": {
      "wind_speed": 3.6,
      "wind_dir": 325,
      "swell_height": 0.5,
      "swell_dir": 220,
      "swell_period": 7.2
    }
  }
};
    </script>

    <script>
    // Hierarchy + centroids. Example shape:
    // {
    //   "Europe": {
    //     "United Kingdom": {
    //       "Cornwall":        {"lat":50.33,"lon":-5.10,"zoom":8},
    //       "Northwest Wales": {"lat":52.85,"lon":-4.58,"zoom":8},
    //       "South Devon":     {"lat":50.35,"lon":-3.90,"zoom":9},
    //       "The West Coast":  {"lat":56.45,"lon":-6.35,"zoom":6}
    //     }
    //   }
    // }
    window.NAV = {"region": {"code": "NEA", "name": "NE Atlantic", "bbox": [-94.46594, 34.42798, 26.0553, 69.62407]}, "countries": [{"code": "BE", "name": "Belgium"}, {"code": "DK", "name": "Denmark"}, {"code": "GB", "name": "England"}, {"code": "FO", "name": "Faroe Islands"}, {"code": "FR", "name": "France"}, {"code": "DE", "name": "Germany"}, {"code": "IS", "name": "Iceland"}, {"code": "IE", "name": "Ireland"}, {"code": "NEA", "name": "NE Atlantic"}, {"code": "NL", "name": "Netherlands"}, {"code": "NIR", "name": "Northern Ireland"}, {"code": "NO", "name": "Norway"}, {"code": "PT", "name": "Portugal"}, {"code": "SCT", "name": "Scotland"}, {"code": "ES", "name": "Spain"}, {"code": "SE", "name": "Sweden"}, {"code": "UK", "name": "United Kingdom"}, {"code": "CYM", "name": "Wales"}], "byCountry": {"GB": [{"id": "/eu/gb/cornwall", "name": "Cornwall", "bbox": [-7.45679, 49.74071, -2.87208, 51.19398]}, {"id": "/eu/gb/north-devon", "name": "North Devon", "bbox": [-4.69282, 50.74296, -2.77851, 51.3424]}, {"id": "/eu/gb/north-yorks", "name": "North Yorks", "bbox": [-2.84109, 53.53485, 0.68496, 54.56577]}, {"id": "/eu/gb/south-coast", "name": "South Coast", "bbox": [-4.14567, 49.96056, 0.83642, 51.53045]}, {"id": "/eu/gb/south-devon", "name": "South Devon", "bbox": [-5.24937, 50.07248, -3.75962, 50.54632]}, {"id": "/eu/gb/the-north-east", "name": "The North East", "bbox": [-5.41705, 54.39914, -0.04508, 55.92725]}], "CYM": [{"id": "/eu/cym/glamorgan", "name": "Glamorgan", "bbox": [-4.01237, 51.27993, -2.20758, 51.83875]}, {"id": "/eu/cym/gower", "name": "Gower", "bbox": [-4.55374, 51.50456, -3.94301, 51.6935]}, {"id": "/eu/cym/northwest-wales", "name": "Northwest Wales", "bbox": [-8.92864, 51.85058, -3.13816, 53.59695]}, {"id": "/eu/cym/pembrokeshire", "name": "Pembrokeshire", "bbox": [-5.85805, 51.57926, -4.48088, 52.00351]}], "CHI": [{"id": "/eu/chi/channel-islands", "name": "nan", "bbox": [-3.1638, 49.1355, -1.91948, 49.53932]}], "SCT": [{"id": "/eu/sct/caithness", "name": "Caithness", "bbox": [-3.71257, 58.46007, -2.87693, 58.6771]}, {"id": "/eu/sct/hebrides", "name": "Hebrides", "bbox": [-12.17333, 56.71434, -4.74721, 58.68997]}, {"id": "/eu/sct/moray", "name": "Moray", "bbox": [-4.58781, 57.32754, -1.70407, 58.09473]}, {"id": "/eu/sct/sutherland", "name": "Sutherland", "bbox": [-5.17617, 58.36359, -3.90032, 58.69533]}, {"id": "/eu/sct/the-east-coast", "name": "The East Coast", "bbox": [-14.15, 55.59271, 6.11, 57.84408]}, {"id": "/eu/sct/the-north", "name": "The North", "bbox": [-9.27226, 56.72384, -1.69002, 58.73933]}, {"id": "/eu/sct/the-west-coast", "name": "The West Coast", "bbox": [-11.597903, 55.171505, -4.124426, 57.497512]}], "NIR": [{"id": "/eu/nir/causeway-coast", "name": "Causeway Coast", "bbox": [-7.56593, 54.91097, -5.9854, 55.36094]}], "IE": [{"id": "/eu/ie/county-clare", "name": "County Clare", "bbox": [-11.005, 52.47035, -8.47168, 53.23225]}, {"id": "/eu/ie/county-sligo", "name": "County Sligo", "bbox": [-10.87, 54.21, -6.49, 54.29]}, {"id": "/eu/ie/dingle-peninsula", "name": "Dingle Peninsula", "bbox": [-10.98594, 52.00235, -9.74773, 52.38039]}, {"id": "/eu/ie/donegal", "name": "Donegal", "bbox": [-9.69, 54.279335, -6.768997, 55.426818]}, {"id": "/eu/ie/the-south", "name": "The South", "bbox": [-10.7236, 51.19293, -6.21868, 52.57766]}], "FR": [{"id": "/eu/fr/biarritz", "name": "Biarritz", "bbox": [-1.84238, 43.37864, -1.41503, 43.53314]}, {"id": "/eu/fr/bretagne", "name": "Bretagne", "bbox": [-5.74759, 47.2598, -0.44871, 49.02065]}, {"id": "/eu/fr/charentes-et-iles", "name": "Charentes et \u00celes", "bbox": [-4.17894, 45.33114, 0.7531, 47.03169]}, {"id": "/eu/fr/cote-basque", "name": "C\u00f4te Basque", "bbox": [-1.8204, 43.34713, -1.58951, 43.4307]}, {"id": "/eu/fr/gironde", "name": "Gironde", "bbox": [-2.79361, 44.58139, 0.08857, 45.59481]}, {"id": "/eu/fr/hossegor", "name": "Hossegor", "bbox": [-1.51549, 43.6374, -1.37995, 43.68624]}, {"id": "/eu/fr/la-manche", "name": "La Manche", "bbox": [-4.21902, 48.44612, 4.76989, 51.32936]}, {"id": "/eu/fr/landes", "name": "Landes", "bbox": [-4.12366, 43.31241, 0.32685, 44.90382]}, {"id": "/eu/fr/vendee", "name": "Vend\u00e9e", "bbox": [-3.67731, 46.22025, -0.17962, 47.41231]}], "ES": [{"id": "/eu/es/andalucia", "name": "Andaluc\u00eda", "bbox": [-6.66457, 35.91454, -4.83656, 36.64845]}, {"id": "/eu/es/asturias", "name": "Asturias", "bbox": [-7.07532, 43.00823, -4.78789, 43.83566]}, {"id": "/eu/es/canary-islands", "name": "Canary Islands", "bbox": [-19.27873, 27.11726, -12.91528, 29.80043]}, {"id": "/eu/es/cantabria", "name": "Cantabria", "bbox": [-5.90522, 42.86, -3.18452, 43.84527]}, {"id": "/eu/es/fuerteventura", "name": "Fuerteventura", "bbox": [-15.29579, 27.97139, -13.29153, 28.84938]}, {"id": "/eu/es/galicia", "name": "Galicia", "bbox": [-10.80027, 41.8692, -5.11763, 43.94196]}, {"id": "/eu/es/gran-canaria", "name": "Gran Canaria", "bbox": [-16.24904, 27.68159, -14.9082, 28.24966]}, {"id": "/eu/es/lanzarote", "name": "Lanzarote", "bbox": [-14.38581, 28.81558, -13.08006, 29.36291]}, {"id": "/eu/es/pais-vasco", "name": "Pa\u00eds Vasco", "bbox": [-3.21492, 43.01859, -1.75754, 43.54698]}, {"id": "/eu/es/tenerife", "name": "Tenerife", "bbox": [-17.62319, 27.94531, -15.81437, 28.70905]}], "PT": [{"id": "/eu/pt/azores", "name": "Azores", "bbox": [-32.37373, 37.1622, -23.741, 40.3895]}, {"id": "/eu/pt/beira-litoral", "name": "Beira Litoral", "bbox": [-11.43115, 39.34048, -7.68287, 40.7693]}, {"id": "/eu/pt/ericeira", "name": "Ericeira", "bbox": [-9.54955, 38.9361, -9.34303, 39.01606]}, {"id": "/eu/pt/lisbon", "name": "Lisbon", "bbox": [-9.97214, 38.35114, -8.5737, 38.89528]}, {"id": "/eu/pt/madeira", "name": "Madeira", "bbox": [-17.39369, 32.57495, -16.51485, 32.92949]}, {"id": "/eu/pt/minho-and-douro", "name": "Minho and Douro", "bbox": [-12.07765, 40.36537, -7.00524, 42.26266]}, {"id": "/eu/pt/peniche", "name": "Peniche", "bbox": [-10.23197, 39.09779, -8.80765, 39.64616]}, {"id": "/eu/pt/southern-portugal", "name": "Southern Portugal", "bbox": [-10.6298, 36.91214, -7.61894, 38.10166]}, {"id": "/eu/pt/sao-jorge", "name": "S\u00e3o Jorge", "bbox": [-28.42662, 38.50657, -27.62704, 38.80608]}, {"id": "/eu/pt/sao-miguel", "name": "S\u00e3o Miguel", "bbox": [-26.02414, 37.61961, -24.99271, 38.01047]}, {"id": "/eu/pt/terceira", "name": "Terceira", "bbox": [-27.5276, 38.6021, -26.88786, 38.84152]}], "IS": [{"id": "/eu/is/reykjanes", "name": "Reykjanes", "bbox": [-23.05549, 63.7965, -21.59133, 64.11666]}], "NO": [{"id": "/eu/no/jaeren", "name": "J\u00e6ren", "bbox": [4.0852, 57.91828, 8.74011, 59.12867]}, {"id": "/eu/no/lofoten", "name": "Lofoten", "bbox": [13.48027, 68.25777, 13.66708, 68.29221]}, {"id": "/eu/no/southern-norway", "name": "Southern Norway", "bbox": [-5.42354, 57.79727, 20.50681, 64.05006]}], "SE": [{"id": "/eu/se/sweden-west", "name": "Sweden West", "bbox": [7.23909, 55.64705, 15.41596, 57.87841]}]}};
    </script>

</head>


<body>

  <div class="page">


    <!-- Header -->
    <div class="header">
    <div class="brand">Spot On</div>


    <div class="meta">
    <!-- Area navigator first -->
        <div id="area-nav" class="area-nav-inline">
            <select id="sel-country" aria-label="Country"></select>
            <select id="sel-area" aria-label="Area">
            <option value="">All</option>
            </select>
        </div>

        <!-- What’s Up + Gales chips -->
        <button id="dials-toggle" class="chip chip-action"
                onclick="toggleDials()"
                aria-pressed="true"
                title="Show or hide the dials panel">
            What’s Up ▴
        </button>

        <button id="synoptic-toggle" class="chip chip-action"
                aria-pressed="false"
                title="Show or hide gale warnings">
            Gales ▾
        </button>

        <!-- Keep Forecast hidden for now -->
        <button id="forecast-toggle" class="chip chip-action"
                onclick="toggleForecast()"
                aria-expanded="false"
                hidden>
            Forecast ▾
        </button>
    </div>



    </div>

    <!-- FULL-WIDTH MAP -->
    <div class="map-wrap">
    <iframe
        id="tv-map"
        src="map_day0.html?v=1767294090"
        allowfullscreen
        allow="fullscreen; geolocation">
    </iframe>


    <!-- Forecast overlay (INSIDE .map-wrap) -->
    <div id="forecast-float" class="forecast-float" hidden role="dialog" aria-label="Regional forecast">
        <div id="forecast-handle" class="forecast-handle">
        <strong>Forecast</strong>
        <button type="button" class="close-x" aria-label="Close" onclick="setPrimaryView('spoton')">✕</button>
        </div>

        <div class="forecast-inner">
        <div id="forecast-header" class="forecast-header" aria-live="polite"></div>
        <div class="forecast-tabs" role="tablist" aria-label="Forecast days">
            <button class="tab" id="tab-0" role="tab" aria-controls="panel-0" aria-selected="true" data-offset="0">Today</button>
            <button class="tab" id="tab-1" role="tab" aria-controls="panel-1" aria-selected="false" data-offset="1">Tomorrow</button>
            <button class="tab" id="tab-2" role="tab" aria-controls="panel-2" aria-selected="false" data-offset="2">+2 Days</button>
        </div>

        <div class="forecast-panels">
            <pre id="panel-0" class="forecast-panel" role="tabpanel" aria-labelledby="tab-0"></pre>
            <pre id="panel-1" class="forecast-panel" role="tabpanel" aria-labelledby="tab-1" hidden></pre>
            <pre id="panel-2" class="forecast-panel" role="tabpanel" aria-labelledby="tab-2" hidden></pre>
        </div>
        </div>
        <span class="resize-handle" aria-hidden="true"></span>
    </div>




    <!-- Dials overlay (ALSO inside .map-wrap) -->
    <div id="dials" class="dials-float" role="region" aria-label="Live spot panel">
        <div id="dials-handle" class="dials-handle">
            <span id="hud-title" class="chip chip-plain">Cornwall</span>
            <button id="tv-date-text" class="chip chip-action" aria-label="Change day" title="Click to cycle days"></button>
            <span id="state-chip" class="state-chip" hidden>Working</span>
        </div>
        <div class="hud-body">
        <div class="dial dial--svg">
            <svg id="dual-dial" viewBox="-130 -130 260 260" aria-label="direction dial">
            <circle cx="0" cy="0" r="110" fill="none" stroke="#e5e5e5" />
            <g id="ticks16"></g>
            <g font-size="12" font-weight="400" fill="#6b7280" text-anchor="middle" dominant-baseline="middle">
                <text x="0"    y="-112" font-size="18" font-weight="700">N</text>
                <text x="115"  y="0"    font-size="18" font-weight="700">E</text>
                <text x="0"    y="128"  font-size="18" font-weight="700">S</text>
                <text x="-115" y="0"    font-size="18" font-weight="700">W</text>
            </g>
            <g id="chev-wind"  class="chev chev--wind"><path d="M-12,-4 L0,-22 L12,-4" /></g>
            <g id="chev-swell" class="chev chev--swell"><path d="M-12,-4 L0,-22 L12,-4" /></g>
            </svg>
        </div>

        <div class="readouts readouts--inline">
            <div class="readout">
            <label>
                <svg id="ro-wind-icon" class="chev-mini chev-mini--wind" viewBox="0 0 14 14" aria-hidden="true">
                <path d="M3,9 L7,3 L11,9" />
                </svg>
                WIND
            </label>
            <strong id="ro-wind">-- mph</strong>
            </div>
            <div class="readout">
            <label>
                <svg id="ro-swell-icon" class="chev-mini chev-mini--swell" viewBox="0 0 14 14" aria-hidden="true">
                <path d="M3,9 L7,3 L11,9" />
                </svg>
                SWELL
            </label>
            <strong id="ro-swell">– ft</strong>
            </div>
            <div class="readout">
            <label>PERIOD</label>
            <strong id="ro-period">– s</strong>
            </div>
        </div>

        <div class="tide-card">
        <svg id="tide-svg" viewBox="0 0 320 84" preserveAspectRatio="xMidYMid meet"></svg>
        </div>

        <div class="tide-info-row">
            <div id="tide-pref-chip" class="chip chip-plain">Tide pref: ALL</div>
            <div id="tv-moon-phase"  class="chip chip-plain">—</div>
        </div>



        <div id="whatsup-summary" class="whatsup-summary" aria-live="polite"></div>
        </div>

        <span class="resize-handle" aria-hidden="true"></span>
    </div>
    </div> <!-- end .map-wrap -->


<script>
  window.TIDES = {"2025-12-31": {"by_port": {"whitby": [{"t": "2025-12-31T00:10", "h": 5.01, "k": "H", "port": "Whitby"}, {"t": "2025-12-31T06:48", "h": 1.69, "k": "L", "port": "Whitby"}, {"t": "2025-12-31T13:00", "h": 4.89, "k": "H", "port": "Whitby"}, {"t": "2025-12-31T19:16", "h": 1.92, "k": "L", "port": "Whitby"}], "scarborough": [{"t": "2025-12-31T00:31", "h": 5.2, "k": "H", "port": "Scarborough"}, {"t": "2025-12-31T07:06", "h": 1.79, "k": "L", "port": "Scarborough"}, {"t": "2025-12-31T13:17", "h": 5.12, "k": "H", "port": "Scarborough"}, {"t": "2025-12-31T19:36", "h": 1.97, "k": "L", "port": "Scarborough"}], "newlyn": [{"t": "2025-12-31T01:12", "h": 4.74, "k": "H", "port": "Newlyn"}, {"t": "2025-12-31T07:53", "h": 1.67, "k": "L", "port": "Newlyn"}, {"t": "2025-12-31T13:43", "h": 4.92, "k": "H", "port": "Newlyn"}, {"t": "2025-12-31T20:27", "h": 1.52, "k": "L", "port": "Newlyn"}], "coomeenole": [{"t": "2025-12-31T01:19", "h": 3.57, "k": "H", "port": "Coomeenole"}, {"t": "2025-12-31T07:28", "h": 1.19, "k": "L", "port": "Coomeenole"}, {"t": "2025-12-31T13:48", "h": 3.61, "k": "H", "port": "Coomeenole"}, {"t": "2025-12-31T19:55", "h": 1.07, "k": "L", "port": "Coomeenole"}], "doonbeg": [{"t": "2025-12-31T01:41", "h": 4.04, "k": "H", "port": "Doonbeg"}, {"t": "2025-12-31T07:51", "h": 1.36, "k": "L", "port": "Doonbeg"}, {"t": "2025-12-31T14:11", "h": 4.05, "k": "H", "port": "Doonbeg"}, {"t": "2025-12-31T20:18", "h": 1.23, "k": "L", "port": "Doonbeg"}], "cork": [{"t": "2025-12-31T01:48", "h": 3.61, "k": "H", "port": "Cork"}, {"t": "2025-12-31T08:21", "h": 1.02, "k": "L", "port": "Cork"}, {"t": "2025-12-31T14:22", "h": 3.65, "k": "H", "port": "Cork"}, {"t": "2025-12-31T20:52", "h": 0.99, "k": "L", "port": "Cork"}], "plymouth": [{"t": "2025-12-31T01:52", "h": 4.72, "k": "H", "port": "Plymouth"}, {"t": "2025-12-31T08:22", "h": 1.97, "k": "L", "port": "Plymouth"}, {"t": "2025-12-31T14:24", "h": 4.75, "k": "H", "port": "Plymouth"}, {"t": "2025-12-31T20:55", "h": 1.83, "k": "L", "port": "Plymouth"}], "bundoran": [{"t": "2025-12-31T02:24", "h": 3.28, "k": "H", "port": "Bundoran"}, {"t": "2025-12-31T08:27", "h": 1.2, "k": "L", "port": "Bundoran"}, {"t": "2025-12-31T14:47", "h": 3.5, "k": "H", "port": "Bundoran"}, {"t": "2025-12-31T21:04", "h": 0.98, "k": "L", "port": "Bundoran"}], "campbeltown": [{"t": "2025-12-31T02:26", "h": 0.87, "k": "L", "port": "Campbeltown"}, {"t": "2025-12-31T09:05", "h": 2.74, "k": "H", "port": "Campbeltown"}, {"t": "2025-12-31T14:49", "h": 0.95, "k": "L", "port": "Campbeltown"}, {"t": "2025-12-31T21:29", "h": 2.91, "k": "H", "port": "Campbeltown"}], "lossiemouth": [{"t": "2025-12-31T02:27", "h": 1.24, "k": "L", "port": "Lossiemouth"}, {"t": "2025-12-31T08:42", "h": 3.53, "k": "H", "port": "Lossiemouth"}, {"t": "2025-12-31T14:57", "h": 1.33, "k": "L", "port": "Lossiemouth"}, {"t": "2025-12-31T21:09", "h": 3.7, "k": "H", "port": "Lossiemouth"}], "inishcrone": [{"t": "2025-12-31T02:32", "h": 3.21, "k": "H", "port": "Inishcrone"}, {"t": "2025-12-31T08:40", "h": 0.93, "k": "L", "port": "Inishcrone"}, {"t": "2025-12-31T15:01", "h": 3.17, "k": "H", "port": "Inishcrone"}, {"t": "2025-12-31T21:03", "h": 0.79, "k": "L", "port": "Inishcrone"}], "llangennith": [{"t": "2025-12-31T02:33", "h": 7.13, "k": "H", "port": "Llangennith"}, {"t": "2025-12-31T08:49", "h": 2.25, "k": "L", "port": "Llangennith"}, {"t": "2025-12-31T15:08", "h": 7.36, "k": "H", "port": "Llangennith"}, {"t": "2025-12-31T21:27", "h": 2.1, "k": "L", "port": "Llangennith"}], "croyde": [{"t": "2025-12-31T02:34", "h": 5.69, "k": "H", "port": "Croyde"}, {"t": "2025-12-31T09:16", "h": 0.79, "k": "L", "port": "Croyde"}, {"t": "2025-12-31T15:08", "h": 5.85, "k": "H", "port": "Croyde"}, {"t": "2025-12-31T21:51", "h": 0.69, "k": "L", "port": "Croyde"}], "falcarragh": [{"t": "2025-12-31T02:38", "h": 3.24, "k": "H", "port": "Falcarragh"}, {"t": "2025-12-31T08:43", "h": 1.13, "k": "L", "port": "Falcarragh"}, {"t": "2025-12-31T15:07", "h": 3.49, "k": "H", "port": "Falcarragh"}, {"t": "2025-12-31T21:21", "h": 1.0, "k": "L", "port": "Falcarragh"}], "milfordhaven": [{"t": "2025-12-31T02:51", "h": 5.87, "k": "H", "port": "MilfordHaven"}, {"t": "2025-12-31T09:10", "h": 1.87, "k": "L", "port": "MilfordHaven"}, {"t": "2025-12-31T15:23", "h": 6.06, "k": "H", "port": "MilfordHaven"}, {"t": "2025-12-31T21:44", "h": 1.71, "k": "L", "port": "MilfordHaven"}], "stornoway": [{"t": "2025-12-31T03:49", "h": 4.19, "k": "H", "port": "Stornoway"}, {"t": "2025-12-31T10:13", "h": 1.7, "k": "L", "port": "Stornoway"}, {"t": "2025-12-31T16:10", "h": 4.33, "k": "H", "port": "Stornoway"}, {"t": "2025-12-31T22:43", "h": 1.42, "k": "L", "port": "Stornoway"}], "aberdeen": [{"t": "2025-12-31T04:01", "h": 1.31, "k": "L", "port": "Aberdeen"}, {"t": "2025-12-31T10:24", "h": 3.81, "k": "H", "port": "Aberdeen"}, {"t": "2025-12-31T16:29", "h": 1.39, "k": "L", "port": "Aberdeen"}, {"t": "2025-12-31T22:49", "h": 4.01, "k": "H", "port": "Aberdeen"}], "londonderry": [{"t": "2025-12-31T04:24", "h": 2.05, "k": "H", "port": "Londonderry"}, {"t": "2025-12-31T11:04", "h": 0.79, "k": "L", "port": "Londonderry"}, {"t": "2025-12-31T16:48", "h": 2.25, "k": "H", "port": "Londonderry"}, {"t": "2025-12-31T23:44", "h": 0.68, "k": "L", "port": "Londonderry"}], "cape wrath": [{"t": "2025-12-31T04:32", "h": 3.93, "k": "H", "port": "Cape Wrath"}, {"t": "2025-12-31T10:47", "h": 1.56, "k": "L", "port": "Cape Wrath"}, {"t": "2025-12-31T16:51", "h": 4.09, "k": "H", "port": "Cape Wrath"}, {"t": "2025-12-31T23:19", "h": 1.26, "k": "L", "port": "Cape Wrath"}], "aberystwyth": [{"t": "2025-12-31T04:46", "h": 4.18, "k": "H", "port": "Aberystwyth"}, {"t": "2025-12-31T11:36", "h": 1.42, "k": "L", "port": "Aberystwyth"}, {"t": "2025-12-31T17:15", "h": 4.41, "k": "H", "port": "Aberystwyth"}], "thurso": [{"t": "2025-12-31T05:37", "h": 4.19, "k": "H", "port": "Thurso"}, {"t": "2025-12-31T11:52", "h": 1.7, "k": "L", "port": "Thurso"}, {"t": "2025-12-31T17:56", "h": 4.29, "k": "H", "port": "Thurso"}], "north shields": [{"t": "2025-12-31T06:18", "h": 1.39, "k": "L", "port": "North Shields"}, {"t": "2025-12-31T12:28", "h": 4.47, "k": "H", "port": "North Shields"}, {"t": "2025-12-31T18:45", "h": 1.6, "k": "L", "port": "North Shields"}], "skirza": [{"t": "2025-12-31T06:28", "h": 3.79, "k": "H", "port": "Skirza"}, {"t": "2025-12-31T12:19", "h": 1.71, "k": "L", "port": "Skirza"}, {"t": "2025-12-31T18:48", "h": 3.88, "k": "H", "port": "Skirza"}]}, "ext": [{"t": "2025-12-31T00:10", "h": 5.01, "k": "H", "port": "Whitby"}, {"t": "2025-12-31T00:31", "h": 5.2, "k": "H", "port": "Scarborough"}, {"t": "2025-12-31T01:12", "h": 4.74, "k": "H", "port": "Newlyn"}, {"t": "2025-12-31T01:19", "h": 3.57, "k": "H", "port": "Coomeenole"}, {"t": "2025-12-31T01:41", "h": 4.04, "k": "H", "port": "Doonbeg"}, {"t": "2025-12-31T01:48", "h": 3.61, "k": "H", "port": "Cork"}, {"t": "2025-12-31T01:52", "h": 4.72, "k": "H", "port": "Plymouth"}, {"t": "2025-12-31T02:24", "h": 3.28, "k": "H", "port": "Bundoran"}, {"t": "2025-12-31T02:26", "h": 0.87, "k": "L", "port": "Campbeltown"}, {"t": "2025-12-31T02:27", "h": 1.24, "k": "L", "port": "Lossiemouth"}, {"t": "2025-12-31T02:32", "h": 3.21, "k": "H", "port": "Inishcrone"}, {"t": "2025-12-31T02:33", "h": 7.13, "k": "H", "port": "Llangennith"}, {"t": "2025-12-31T02:34", "h": 5.69, "k": "H", "port": "Croyde"}, {"t": "2025-12-31T02:38", "h": 3.24, "k": "H", "port": "Falcarragh"}, {"t": "2025-12-31T02:51", "h": 5.87, "k": "H", "port": "MilfordHaven"}, {"t": "2025-12-31T03:49", "h": 4.19, "k": "H", "port": "Stornoway"}, {"t": "2025-12-31T04:01", "h": 1.31, "k": "L", "port": "Aberdeen"}, {"t": "2025-12-31T04:24", "h": 2.05, "k": "H", "port": "Londonderry"}, {"t": "2025-12-31T04:32", "h": 3.93, "k": "H", "port": "Cape Wrath"}, {"t": "2025-12-31T04:46", "h": 4.18, "k": "H", "port": "Aberystwyth"}, {"t": "2025-12-31T05:37", "h": 4.19, "k": "H", "port": "Thurso"}, {"t": "2025-12-31T06:18", "h": 1.39, "k": "L", "port": "North Shields"}, {"t": "2025-12-31T06:28", "h": 3.79, "k": "H", "port": "Skirza"}, {"t": "2025-12-31T06:48", "h": 1.69, "k": "L", "port": "Whitby"}, {"t": "2025-12-31T07:06", "h": 1.79, "k": "L", "port": "Scarborough"}, {"t": "2025-12-31T07:28", "h": 1.19, "k": "L", "port": "Coomeenole"}, {"t": "2025-12-31T07:51", "h": 1.36, "k": "L", "port": "Doonbeg"}, {"t": "2025-12-31T07:53", "h": 1.67, "k": "L", "port": "Newlyn"}, {"t": "2025-12-31T08:21", "h": 1.02, "k": "L", "port": "Cork"}, {"t": "2025-12-31T08:22", "h": 1.97, "k": "L", "port": "Plymouth"}, {"t": "2025-12-31T08:27", "h": 1.2, "k": "L", "port": "Bundoran"}, {"t": "2025-12-31T08:40", "h": 0.93, "k": "L", "port": "Inishcrone"}, {"t": "2025-12-31T08:42", "h": 3.53, "k": "H", "port": "Lossiemouth"}, {"t": "2025-12-31T08:43", "h": 1.13, "k": "L", "port": "Falcarragh"}, {"t": "2025-12-31T08:49", "h": 2.25, "k": "L", "port": "Llangennith"}, {"t": "2025-12-31T09:05", "h": 2.74, "k": "H", "port": "Campbeltown"}, {"t": "2025-12-31T09:10", "h": 1.87, "k": "L", "port": "MilfordHaven"}, {"t": "2025-12-31T09:16", "h": 0.79, "k": "L", "port": "Croyde"}, {"t": "2025-12-31T10:13", "h": 1.7, "k": "L", "port": "Stornoway"}, {"t": "2025-12-31T10:24", "h": 3.81, "k": "H", "port": "Aberdeen"}, {"t": "2025-12-31T10:47", "h": 1.56, "k": "L", "port": "Cape Wrath"}, {"t": "2025-12-31T11:04", "h": 0.79, "k": "L", "port": "Londonderry"}, {"t": "2025-12-31T11:36", "h": 1.42, "k": "L", "port": "Aberystwyth"}, {"t": "2025-12-31T11:52", "h": 1.7, "k": "L", "port": "Thurso"}, {"t": "2025-12-31T12:19", "h": 1.71, "k": "L", "port": "Skirza"}, {"t": "2025-12-31T12:28", "h": 4.47, "k": "H", "port": "North Shields"}, {"t": "2025-12-31T13:00", "h": 4.89, "k": "H", "port": "Whitby"}, {"t": "2025-12-31T13:17", "h": 5.12, "k": "H", "port": "Scarborough"}, {"t": "2025-12-31T13:43", "h": 4.92, "k": "H", "port": "Newlyn"}, {"t": "2025-12-31T13:48", "h": 3.61, "k": "H", "port": "Coomeenole"}, {"t": "2025-12-31T14:11", "h": 4.05, "k": "H", "port": "Doonbeg"}, {"t": "2025-12-31T14:22", "h": 3.65, "k": "H", "port": "Cork"}, {"t": "2025-12-31T14:24", "h": 4.75, "k": "H", "port": "Plymouth"}, {"t": "2025-12-31T14:47", "h": 3.5, "k": "H", "port": "Bundoran"}, {"t": "2025-12-31T14:49", "h": 0.95, "k": "L", "port": "Campbeltown"}, {"t": "2025-12-31T14:57", "h": 1.33, "k": "L", "port": "Lossiemouth"}, {"t": "2025-12-31T15:01", "h": 3.17, "k": "H", "port": "Inishcrone"}, {"t": "2025-12-31T15:07", "h": 3.49, "k": "H", "port": "Falcarragh"}, {"t": "2025-12-31T15:08", "h": 7.36, "k": "H", "port": "Llangennith"}, {"t": "2025-12-31T15:08", "h": 5.85, "k": "H", "port": "Croyde"}, {"t": "2025-12-31T15:23", "h": 6.06, "k": "H", "port": "MilfordHaven"}, {"t": "2025-12-31T16:10", "h": 4.33, "k": "H", "port": "Stornoway"}, {"t": "2025-12-31T16:29", "h": 1.39, "k": "L", "port": "Aberdeen"}, {"t": "2025-12-31T16:48", "h": 2.25, "k": "H", "port": "Londonderry"}, {"t": "2025-12-31T16:51", "h": 4.09, "k": "H", "port": "Cape Wrath"}, {"t": "2025-12-31T17:15", "h": 4.41, "k": "H", "port": "Aberystwyth"}, {"t": "2025-12-31T17:56", "h": 4.29, "k": "H", "port": "Thurso"}, {"t": "2025-12-31T18:45", "h": 1.6, "k": "L", "port": "North Shields"}, {"t": "2025-12-31T18:48", "h": 3.88, "k": "H", "port": "Skirza"}, {"t": "2025-12-31T19:16", "h": 1.92, "k": "L", "port": "Whitby"}, {"t": "2025-12-31T19:36", "h": 1.97, "k": "L", "port": "Scarborough"}, {"t": "2025-12-31T19:55", "h": 1.07, "k": "L", "port": "Coomeenole"}, {"t": "2025-12-31T20:18", "h": 1.23, "k": "L", "port": "Doonbeg"}, {"t": "2025-12-31T20:27", "h": 1.52, "k": "L", "port": "Newlyn"}, {"t": "2025-12-31T20:52", "h": 0.99, "k": "L", "port": "Cork"}, {"t": "2025-12-31T20:55", "h": 1.83, "k": "L", "port": "Plymouth"}, {"t": "2025-12-31T21:03", "h": 0.79, "k": "L", "port": "Inishcrone"}, {"t": "2025-12-31T21:04", "h": 0.98, "k": "L", "port": "Bundoran"}, {"t": "2025-12-31T21:09", "h": 3.7, "k": "H", "port": "Lossiemouth"}, {"t": "2025-12-31T21:21", "h": 1.0, "k": "L", "port": "Falcarragh"}, {"t": "2025-12-31T21:27", "h": 2.1, "k": "L", "port": "Llangennith"}, {"t": "2025-12-31T21:29", "h": 2.91, "k": "H", "port": "Campbeltown"}, {"t": "2025-12-31T21:44", "h": 1.71, "k": "L", "port": "MilfordHaven"}, {"t": "2025-12-31T21:51", "h": 0.69, "k": "L", "port": "Croyde"}, {"t": "2025-12-31T22:43", "h": 1.42, "k": "L", "port": "Stornoway"}, {"t": "2025-12-31T22:49", "h": 4.01, "k": "H", "port": "Aberdeen"}, {"t": "2025-12-31T23:19", "h": 1.26, "k": "L", "port": "Cape Wrath"}, {"t": "2025-12-31T23:44", "h": 0.68, "k": "L", "port": "Londonderry"}], "sunrise": "2025-12-31T08:20", "sunset": "2025-12-31T16:25"}, "2026-01-01": {"by_port": {"aberystwyth": [{"t": "2026-01-01T00:13", "h": 1.27, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-01T05:45", "h": 4.51, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-01T12:46", "h": 1.17, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-01T18:11", "h": 4.62, "k": "H", "port": "Aberystwyth"}], "north shields": [{"t": "2026-01-01T00:46", "h": 4.72, "k": "H", "port": "North Shields"}, {"t": "2026-01-01T07:21", "h": 1.29, "k": "L", "port": "North Shields"}, {"t": "2026-01-01T13:26", "h": 4.68, "k": "H", "port": "North Shields"}, {"t": "2026-01-01T19:48", "h": 1.3, "k": "L", "port": "North Shields"}], "skirza": [{"t": "2026-01-01T00:48", "h": 1.47, "k": "L", "port": "Skirza"}, {"t": "2026-01-01T07:30", "h": 3.98, "k": "H", "port": "Skirza"}, {"t": "2026-01-01T13:18", "h": 1.45, "k": "L", "port": "Skirza"}, {"t": "2026-01-01T19:59", "h": 3.99, "k": "H", "port": "Skirza"}], "whitby": [{"t": "2026-01-01T01:08", "h": 5.03, "k": "H", "port": "Whitby"}, {"t": "2026-01-01T07:36", "h": 1.41, "k": "L", "port": "Whitby"}, {"t": "2026-01-01T13:41", "h": 5.05, "k": "H", "port": "Whitby"}, {"t": "2026-01-01T20:05", "h": 1.32, "k": "L", "port": "Whitby"}], "scarborough": [{"t": "2026-01-01T01:18", "h": 5.16, "k": "H", "port": "Scarborough"}, {"t": "2026-01-01T07:51", "h": 1.58, "k": "L", "port": "Scarborough"}, {"t": "2026-01-01T13:57", "h": 5.11, "k": "H", "port": "Scarborough"}, {"t": "2026-01-01T20:19", "h": 1.6, "k": "L", "port": "Scarborough"}], "newlyn": [{"t": "2026-01-01T02:17", "h": 4.98, "k": "H", "port": "Newlyn"}, {"t": "2026-01-01T09:03", "h": 1.43, "k": "L", "port": "Newlyn"}, {"t": "2026-01-01T14:45", "h": 5.09, "k": "H", "port": "Newlyn"}, {"t": "2026-01-01T21:31", "h": 1.32, "k": "L", "port": "Newlyn"}], "coomeenole": [{"t": "2026-01-01T02:20", "h": 3.76, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-01T08:29", "h": 0.97, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-01T14:51", "h": 3.79, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-01T20:53", "h": 0.94, "k": "L", "port": "Coomeenole"}], "doonbeg": [{"t": "2026-01-01T02:42", "h": 4.25, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-01T08:52", "h": 1.11, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-01T15:14", "h": 4.26, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-01T21:15", "h": 1.08, "k": "L", "port": "Doonbeg"}], "cork": [{"t": "2026-01-01T02:52", "h": 3.79, "k": "H", "port": "Cork"}, {"t": "2026-01-01T09:26", "h": 0.87, "k": "L", "port": "Cork"}, {"t": "2026-01-01T15:22", "h": 3.81, "k": "H", "port": "Cork"}, {"t": "2026-01-01T21:53", "h": 0.8, "k": "L", "port": "Cork"}], "plymouth": [{"t": "2026-01-01T03:11", "h": 4.92, "k": "H", "port": "Plymouth"}, {"t": "2026-01-01T09:39", "h": 1.5, "k": "L", "port": "Plymouth"}, {"t": "2026-01-01T15:40", "h": 4.91, "k": "H", "port": "Plymouth"}, {"t": "2026-01-01T22:06", "h": 1.36, "k": "L", "port": "Plymouth"}], "bundoran": [{"t": "2026-01-01T03:25", "h": 3.52, "k": "H", "port": "Bundoran"}, {"t": "2026-01-01T09:32", "h": 0.99, "k": "L", "port": "Bundoran"}, {"t": "2026-01-01T15:51", "h": 3.62, "k": "H", "port": "Bundoran"}, {"t": "2026-01-01T21:59", "h": 0.85, "k": "L", "port": "Bundoran"}], "campbeltown": [{"t": "2026-01-01T03:25", "h": 0.85, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-01T10:05", "h": 2.86, "k": "H", "port": "Campbeltown"}, {"t": "2026-01-01T15:53", "h": 0.81, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-01T22:38", "h": 2.94, "k": "H", "port": "Campbeltown"}], "lossiemouth": [{"t": "2026-01-01T03:31", "h": 1.15, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-01T09:44", "h": 3.72, "k": "H", "port": "Lossiemouth"}, {"t": "2026-01-01T16:01", "h": 1.06, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-01T22:16", "h": 3.83, "k": "H", "port": "Lossiemouth"}], "inishcrone": [{"t": "2026-01-01T03:32", "h": 3.45, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-01T09:38", "h": 0.64, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-01T16:03", "h": 3.37, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-01T21:57", "h": 0.61, "k": "L", "port": "Inishcrone"}], "falcarragh": [{"t": "2026-01-01T03:39", "h": 3.47, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-01T09:47", "h": 0.93, "k": "L", "port": "Falcarragh"}, {"t": "2026-01-01T16:07", "h": 3.62, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-01T22:16", "h": 0.84, "k": "L", "port": "Falcarragh"}], "croyde": [{"t": "2026-01-01T03:40", "h": 6.04, "k": "H", "port": "Croyde"}, {"t": "2026-01-01T10:28", "h": 0.5, "k": "L", "port": "Croyde"}, {"t": "2026-01-01T16:10", "h": 6.17, "k": "H", "port": "Croyde"}, {"t": "2026-01-01T22:59", "h": 0.41, "k": "L", "port": "Croyde"}], "llangennith": [{"t": "2026-01-01T03:42", "h": 7.49, "k": "H", "port": "Llangennith"}, {"t": "2026-01-01T10:00", "h": 1.91, "k": "L", "port": "Llangennith"}, {"t": "2026-01-01T16:15", "h": 7.71, "k": "H", "port": "Llangennith"}, {"t": "2026-01-01T22:32", "h": 1.78, "k": "L", "port": "Llangennith"}], "milfordhaven": [{"t": "2026-01-01T03:50", "h": 2.45, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-01T10:08", "h": -2.19, "k": "L", "port": "MilfordHaven"}, {"t": "2026-01-01T16:20", "h": 2.58, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-01T22:36", "h": -2.31, "k": "L", "port": "MilfordHaven"}], "stornoway": [{"t": "2026-01-01T04:48", "h": 4.46, "k": "H", "port": "Stornoway"}, {"t": "2026-01-01T11:16", "h": 1.4, "k": "L", "port": "Stornoway"}, {"t": "2026-01-01T17:11", "h": 4.46, "k": "H", "port": "Stornoway"}, {"t": "2026-01-01T23:38", "h": 1.23, "k": "L", "port": "Stornoway"}], "aberdeen": [{"t": "2026-01-01T05:02", "h": 1.22, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-01T11:23", "h": 4.01, "k": "H", "port": "Aberdeen"}, {"t": "2026-01-01T17:30", "h": 1.13, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-01T23:53", "h": 4.14, "k": "H", "port": "Aberdeen"}], "cape wrath": [{"t": "2026-01-01T05:29", "h": 4.14, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-01T11:48", "h": 1.28, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-01T17:53", "h": 4.26, "k": "H", "port": "Cape Wrath"}], "londonderry": [{"t": "2026-01-01T05:34", "h": 2.24, "k": "H", "port": "Londonderry"}, {"t": "2026-01-01T11:57", "h": 0.64, "k": "L", "port": "Londonderry"}, {"t": "2026-01-01T17:58", "h": 2.29, "k": "H", "port": "Londonderry"}]}, "ext": [{"t": "2026-01-01T00:13", "h": 1.27, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-01T00:46", "h": 4.72, "k": "H", "port": "North Shields"}, {"t": "2026-01-01T00:48", "h": 1.47, "k": "L", "port": "Skirza"}, {"t": "2026-01-01T01:08", "h": 5.03, "k": "H", "port": "Whitby"}, {"t": "2026-01-01T01:18", "h": 5.16, "k": "H", "port": "Scarborough"}, {"t": "2026-01-01T02:17", "h": 4.98, "k": "H", "port": "Newlyn"}, {"t": "2026-01-01T02:20", "h": 3.76, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-01T02:42", "h": 4.25, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-01T02:52", "h": 3.79, "k": "H", "port": "Cork"}, {"t": "2026-01-01T03:11", "h": 4.92, "k": "H", "port": "Plymouth"}, {"t": "2026-01-01T03:25", "h": 3.52, "k": "H", "port": "Bundoran"}, {"t": "2026-01-01T03:25", "h": 0.85, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-01T03:31", "h": 1.15, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-01T03:32", "h": 3.45, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-01T03:39", "h": 3.47, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-01T03:40", "h": 6.04, "k": "H", "port": "Croyde"}, {"t": "2026-01-01T03:42", "h": 7.49, "k": "H", "port": "Llangennith"}, {"t": "2026-01-01T03:50", "h": 2.45, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-01T04:48", "h": 4.46, "k": "H", "port": "Stornoway"}, {"t": "2026-01-01T05:02", "h": 1.22, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-01T05:29", "h": 4.14, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-01T05:34", "h": 2.24, "k": "H", "port": "Londonderry"}, {"t": "2026-01-01T05:45", "h": 4.51, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-01T07:21", "h": 1.29, "k": "L", "port": "North Shields"}, {"t": "2026-01-01T07:30", "h": 3.98, "k": "H", "port": "Skirza"}, {"t": "2026-01-01T07:36", "h": 1.41, "k": "L", "port": "Whitby"}, {"t": "2026-01-01T07:51", "h": 1.58, "k": "L", "port": "Scarborough"}, {"t": "2026-01-01T08:29", "h": 0.97, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-01T08:52", "h": 1.11, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-01T09:03", "h": 1.43, "k": "L", "port": "Newlyn"}, {"t": "2026-01-01T09:26", "h": 0.87, "k": "L", "port": "Cork"}, {"t": "2026-01-01T09:32", "h": 0.99, "k": "L", "port": "Bundoran"}, {"t": "2026-01-01T09:38", "h": 0.64, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-01T09:39", "h": 1.5, "k": "L", "port": "Plymouth"}, {"t": "2026-01-01T09:44", "h": 3.72, "k": "H", "port": "Lossiemouth"}, {"t": "2026-01-01T09:47", "h": 0.93, "k": "L", "port": "Falcarragh"}, {"t": "2026-01-01T10:00", "h": 1.91, "k": "L", "port": "Llangennith"}, {"t": "2026-01-01T10:05", "h": 2.86, "k": "H", "port": "Campbeltown"}, {"t": "2026-01-01T10:08", "h": -2.19, "k": "L", "port": "MilfordHaven"}, {"t": "2026-01-01T10:28", "h": 0.5, "k": "L", "port": "Croyde"}, {"t": "2026-01-01T11:16", "h": 1.4, "k": "L", "port": "Stornoway"}, {"t": "2026-01-01T11:23", "h": 4.01, "k": "H", "port": "Aberdeen"}, {"t": "2026-01-01T11:48", "h": 1.28, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-01T11:57", "h": 0.64, "k": "L", "port": "Londonderry"}, {"t": "2026-01-01T12:46", "h": 1.17, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-01T13:18", "h": 1.45, "k": "L", "port": "Skirza"}, {"t": "2026-01-01T13:26", "h": 4.68, "k": "H", "port": "North Shields"}, {"t": "2026-01-01T13:41", "h": 5.05, "k": "H", "port": "Whitby"}, {"t": "2026-01-01T13:57", "h": 5.11, "k": "H", "port": "Scarborough"}, {"t": "2026-01-01T14:45", "h": 5.09, "k": "H", "port": "Newlyn"}, {"t": "2026-01-01T14:51", "h": 3.79, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-01T15:14", "h": 4.26, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-01T15:22", "h": 3.81, "k": "H", "port": "Cork"}, {"t": "2026-01-01T15:40", "h": 4.91, "k": "H", "port": "Plymouth"}, {"t": "2026-01-01T15:51", "h": 3.62, "k": "H", "port": "Bundoran"}, {"t": "2026-01-01T15:53", "h": 0.81, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-01T16:01", "h": 1.06, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-01T16:03", "h": 3.37, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-01T16:07", "h": 3.62, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-01T16:10", "h": 6.17, "k": "H", "port": "Croyde"}, {"t": "2026-01-01T16:15", "h": 7.71, "k": "H", "port": "Llangennith"}, {"t": "2026-01-01T16:20", "h": 2.58, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-01T17:11", "h": 4.46, "k": "H", "port": "Stornoway"}, {"t": "2026-01-01T17:30", "h": 1.13, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-01T17:53", "h": 4.26, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-01T17:58", "h": 2.29, "k": "H", "port": "Londonderry"}, {"t": "2026-01-01T18:11", "h": 4.62, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-01T19:48", "h": 1.3, "k": "L", "port": "North Shields"}, {"t": "2026-01-01T19:59", "h": 3.99, "k": "H", "port": "Skirza"}, {"t": "2026-01-01T20:05", "h": 1.32, "k": "L", "port": "Whitby"}, {"t": "2026-01-01T20:19", "h": 1.6, "k": "L", "port": "Scarborough"}, {"t": "2026-01-01T20:53", "h": 0.94, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-01T21:15", "h": 1.08, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-01T21:31", "h": 1.32, "k": "L", "port": "Newlyn"}, {"t": "2026-01-01T21:53", "h": 0.8, "k": "L", "port": "Cork"}, {"t": "2026-01-01T21:57", "h": 0.61, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-01T21:59", "h": 0.85, "k": "L", "port": "Bundoran"}, {"t": "2026-01-01T22:06", "h": 1.36, "k": "L", "port": "Plymouth"}, {"t": "2026-01-01T22:16", "h": 3.83, "k": "H", "port": "Lossiemouth"}, {"t": "2026-01-01T22:16", "h": 0.84, "k": "L", "port": "Falcarragh"}, {"t": "2026-01-01T22:32", "h": 1.78, "k": "L", "port": "Llangennith"}, {"t": "2026-01-01T22:36", "h": -2.31, "k": "L", "port": "MilfordHaven"}, {"t": "2026-01-01T22:38", "h": 2.94, "k": "H", "port": "Campbeltown"}, {"t": "2026-01-01T22:59", "h": 0.41, "k": "L", "port": "Croyde"}, {"t": "2026-01-01T23:38", "h": 1.23, "k": "L", "port": "Stornoway"}, {"t": "2026-01-01T23:53", "h": 4.14, "k": "H", "port": "Aberdeen"}], "sunrise": "2026-01-01T08:20", "sunset": "2026-01-01T16:26"}, "2026-01-02": {"by_port": {"cape wrath": [{"t": "2026-01-02T00:15", "h": 1.11, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-02T06:22", "h": 4.36, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-02T12:43", "h": 0.99, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-02T18:51", "h": 4.4, "k": "H", "port": "Cape Wrath"}], "londonderry": [{"t": "2026-01-02T00:21", "h": 0.56, "k": "L", "port": "Londonderry"}, {"t": "2026-01-02T06:27", "h": 2.43, "k": "H", "port": "Londonderry"}, {"t": "2026-01-02T12:55", "h": 0.53, "k": "L", "port": "Londonderry"}, {"t": "2026-01-02T18:48", "h": 2.33, "k": "H", "port": "Londonderry"}], "aberystwyth": [{"t": "2026-01-02T01:15", "h": 1.08, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-02T06:36", "h": 4.83, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-02T13:48", "h": 0.9, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-02T19:01", "h": 4.8, "k": "H", "port": "Aberystwyth"}], "skirza": [{"t": "2026-01-02T01:41", "h": 1.36, "k": "L", "port": "Skirza"}, {"t": "2026-01-02T08:26", "h": 4.17, "k": "H", "port": "Skirza"}, {"t": "2026-01-02T14:11", "h": 1.21, "k": "L", "port": "Skirza"}, {"t": "2026-01-02T21:01", "h": 4.1, "k": "H", "port": "Skirza"}], "north shields": [{"t": "2026-01-02T01:49", "h": 4.9, "k": "H", "port": "North Shields"}, {"t": "2026-01-02T08:17", "h": 1.19, "k": "L", "port": "North Shields"}, {"t": "2026-01-02T14:18", "h": 4.9, "k": "H", "port": "North Shields"}, {"t": "2026-01-02T20:45", "h": 0.99, "k": "L", "port": "North Shields"}], "whitby": [{"t": "2026-01-02T02:09", "h": 5.21, "k": "H", "port": "Whitby"}, {"t": "2026-01-02T08:33", "h": 1.26, "k": "L", "port": "Whitby"}, {"t": "2026-01-02T14:34", "h": 5.31, "k": "H", "port": "Whitby"}, {"t": "2026-01-02T21:01", "h": 1.01, "k": "L", "port": "Whitby"}], "scarborough": [{"t": "2026-01-02T02:20", "h": 5.33, "k": "H", "port": "Scarborough"}, {"t": "2026-01-02T08:48", "h": 1.47, "k": "L", "port": "Scarborough"}, {"t": "2026-01-02T14:49", "h": 5.33, "k": "H", "port": "Scarborough"}, {"t": "2026-01-02T21:15", "h": 1.27, "k": "L", "port": "Scarborough"}], "newlyn": [{"t": "2026-01-02T03:14", "h": 5.24, "k": "H", "port": "Newlyn"}, {"t": "2026-01-02T10:04", "h": 1.17, "k": "L", "port": "Newlyn"}, {"t": "2026-01-02T15:40", "h": 5.24, "k": "H", "port": "Newlyn"}, {"t": "2026-01-02T22:28", "h": 1.13, "k": "L", "port": "Newlyn"}], "coomeenole": [{"t": "2026-01-02T03:16", "h": 3.97, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-02T09:25", "h": 0.75, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-02T15:48", "h": 3.96, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-02T21:46", "h": 0.82, "k": "L", "port": "Coomeenole"}], "doonbeg": [{"t": "2026-01-02T03:38", "h": 4.49, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-02T09:47", "h": 0.85, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-02T16:10", "h": 4.45, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-02T22:08", "h": 0.94, "k": "L", "port": "Doonbeg"}], "cork": [{"t": "2026-01-02T03:49", "h": 3.99, "k": "H", "port": "Cork"}, {"t": "2026-01-02T10:25", "h": 0.7, "k": "L", "port": "Cork"}, {"t": "2026-01-02T16:16", "h": 3.97, "k": "H", "port": "Cork"}, {"t": "2026-01-02T22:49", "h": 0.63, "k": "L", "port": "Cork"}], "plymouth": [{"t": "2026-01-02T04:11", "h": 5.15, "k": "H", "port": "Plymouth"}, {"t": "2026-01-02T10:38", "h": 1.19, "k": "L", "port": "Plymouth"}, {"t": "2026-01-02T16:41", "h": 5.06, "k": "H", "port": "Plymouth"}, {"t": "2026-01-02T23:00", "h": 1.11, "k": "L", "port": "Plymouth"}], "bundoran": [{"t": "2026-01-02T04:21", "h": 3.77, "k": "H", "port": "Bundoran"}, {"t": "2026-01-02T10:30", "h": 0.77, "k": "L", "port": "Bundoran"}, {"t": "2026-01-02T16:48", "h": 3.73, "k": "H", "port": "Bundoran"}, {"t": "2026-01-02T22:49", "h": 0.71, "k": "L", "port": "Bundoran"}], "campbeltown": [{"t": "2026-01-02T04:21", "h": 0.82, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-02T11:03", "h": 3.0, "k": "H", "port": "Campbeltown"}, {"t": "2026-01-02T16:52", "h": 0.66, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-02T23:41", "h": 2.98, "k": "H", "port": "Campbeltown"}], "inishcrone": [{"t": "2026-01-02T04:26", "h": 3.71, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-02T10:31", "h": 0.36, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-02T16:57", "h": 3.56, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-02T22:47", "h": 0.45, "k": "L", "port": "Inishcrone"}], "lossiemouth": [{"t": "2026-01-02T04:28", "h": 1.05, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-02T10:42", "h": 3.93, "k": "H", "port": "Lossiemouth"}, {"t": "2026-01-02T16:56", "h": 0.81, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-02T23:17", "h": 3.97, "k": "H", "port": "Lossiemouth"}], "falcarragh": [{"t": "2026-01-02T04:35", "h": 3.71, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-02T10:44", "h": 0.73, "k": "L", "port": "Falcarragh"}, {"t": "2026-01-02T17:03", "h": 3.74, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-02T23:07", "h": 0.69, "k": "L", "port": "Falcarragh"}], "croyde": [{"t": "2026-01-02T04:38", "h": 6.46, "k": "H", "port": "Croyde"}, {"t": "2026-01-02T11:33", "h": 0.15, "k": "L", "port": "Croyde"}, {"t": "2026-01-02T17:05", "h": 6.51, "k": "H", "port": "Croyde"}], "llangennith": [{"t": "2026-01-02T04:44", "h": 7.92, "k": "H", "port": "Llangennith"}, {"t": "2026-01-02T11:03", "h": 1.51, "k": "L", "port": "Llangennith"}, {"t": "2026-01-02T17:14", "h": 8.07, "k": "H", "port": "Llangennith"}, {"t": "2026-01-02T23:30", "h": 1.45, "k": "L", "port": "Llangennith"}], "milfordhaven": [{"t": "2026-01-02T04:47", "h": 2.83, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-02T11:08", "h": -2.51, "k": "L", "port": "MilfordHaven"}, {"t": "2026-01-02T17:15", "h": 2.85, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-02T23:31", "h": -2.58, "k": "L", "port": "MilfordHaven"}], "stornoway": [{"t": "2026-01-02T05:41", "h": 4.71, "k": "H", "port": "Stornoway"}, {"t": "2026-01-02T12:11", "h": 1.12, "k": "L", "port": "Stornoway"}, {"t": "2026-01-02T18:07", "h": 4.57, "k": "H", "port": "Stornoway"}], "aberdeen": [{"t": "2026-01-02T05:57", "h": 1.11, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-02T12:16", "h": 4.22, "k": "H", "port": "Aberdeen"}, {"t": "2026-01-02T18:24", "h": 0.88, "k": "L", "port": "Aberdeen"}]}, "ext": [{"t": "2026-01-02T00:15", "h": 1.11, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-02T00:21", "h": 0.56, "k": "L", "port": "Londonderry"}, {"t": "2026-01-02T01:15", "h": 1.08, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-02T01:41", "h": 1.36, "k": "L", "port": "Skirza"}, {"t": "2026-01-02T01:49", "h": 4.9, "k": "H", "port": "North Shields"}, {"t": "2026-01-02T02:09", "h": 5.21, "k": "H", "port": "Whitby"}, {"t": "2026-01-02T02:20", "h": 5.33, "k": "H", "port": "Scarborough"}, {"t": "2026-01-02T03:14", "h": 5.24, "k": "H", "port": "Newlyn"}, {"t": "2026-01-02T03:16", "h": 3.97, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-02T03:38", "h": 4.49, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-02T03:49", "h": 3.99, "k": "H", "port": "Cork"}, {"t": "2026-01-02T04:11", "h": 5.15, "k": "H", "port": "Plymouth"}, {"t": "2026-01-02T04:21", "h": 3.77, "k": "H", "port": "Bundoran"}, {"t": "2026-01-02T04:21", "h": 0.82, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-02T04:26", "h": 3.71, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-02T04:28", "h": 1.05, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-02T04:35", "h": 3.71, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-02T04:38", "h": 6.46, "k": "H", "port": "Croyde"}, {"t": "2026-01-02T04:44", "h": 7.92, "k": "H", "port": "Llangennith"}, {"t": "2026-01-02T04:47", "h": 2.83, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-02T05:41", "h": 4.71, "k": "H", "port": "Stornoway"}, {"t": "2026-01-02T05:57", "h": 1.11, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-02T06:22", "h": 4.36, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-02T06:27", "h": 2.43, "k": "H", "port": "Londonderry"}, {"t": "2026-01-02T06:36", "h": 4.83, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-02T08:17", "h": 1.19, "k": "L", "port": "North Shields"}, {"t": "2026-01-02T08:26", "h": 4.17, "k": "H", "port": "Skirza"}, {"t": "2026-01-02T08:33", "h": 1.26, "k": "L", "port": "Whitby"}, {"t": "2026-01-02T08:48", "h": 1.47, "k": "L", "port": "Scarborough"}, {"t": "2026-01-02T09:25", "h": 0.75, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-02T09:47", "h": 0.85, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-02T10:04", "h": 1.17, "k": "L", "port": "Newlyn"}, {"t": "2026-01-02T10:25", "h": 0.7, "k": "L", "port": "Cork"}, {"t": "2026-01-02T10:30", "h": 0.77, "k": "L", "port": "Bundoran"}, {"t": "2026-01-02T10:31", "h": 0.36, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-02T10:38", "h": 1.19, "k": "L", "port": "Plymouth"}, {"t": "2026-01-02T10:42", "h": 3.93, "k": "H", "port": "Lossiemouth"}, {"t": "2026-01-02T10:44", "h": 0.73, "k": "L", "port": "Falcarragh"}, {"t": "2026-01-02T11:03", "h": 1.51, "k": "L", "port": "Llangennith"}, {"t": "2026-01-02T11:03", "h": 3.0, "k": "H", "port": "Campbeltown"}, {"t": "2026-01-02T11:08", "h": -2.51, "k": "L", "port": "MilfordHaven"}, {"t": "2026-01-02T11:33", "h": 0.15, "k": "L", "port": "Croyde"}, {"t": "2026-01-02T12:11", "h": 1.12, "k": "L", "port": "Stornoway"}, {"t": "2026-01-02T12:16", "h": 4.22, "k": "H", "port": "Aberdeen"}, {"t": "2026-01-02T12:43", "h": 0.99, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-02T12:55", "h": 0.53, "k": "L", "port": "Londonderry"}, {"t": "2026-01-02T13:48", "h": 0.9, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-02T14:11", "h": 1.21, "k": "L", "port": "Skirza"}, {"t": "2026-01-02T14:18", "h": 4.9, "k": "H", "port": "North Shields"}, {"t": "2026-01-02T14:34", "h": 5.31, "k": "H", "port": "Whitby"}, {"t": "2026-01-02T14:49", "h": 5.33, "k": "H", "port": "Scarborough"}, {"t": "2026-01-02T15:40", "h": 5.24, "k": "H", "port": "Newlyn"}, {"t": "2026-01-02T15:48", "h": 3.96, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-02T16:10", "h": 4.45, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-02T16:16", "h": 3.97, "k": "H", "port": "Cork"}, {"t": "2026-01-02T16:41", "h": 5.06, "k": "H", "port": "Plymouth"}, {"t": "2026-01-02T16:48", "h": 3.73, "k": "H", "port": "Bundoran"}, {"t": "2026-01-02T16:52", "h": 0.66, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-02T16:56", "h": 0.81, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-02T16:57", "h": 3.56, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-02T17:03", "h": 3.74, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-02T17:05", "h": 6.51, "k": "H", "port": "Croyde"}, {"t": "2026-01-02T17:14", "h": 8.07, "k": "H", "port": "Llangennith"}, {"t": "2026-01-02T17:15", "h": 2.85, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-02T18:07", "h": 4.57, "k": "H", "port": "Stornoway"}, {"t": "2026-01-02T18:24", "h": 0.88, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-02T18:48", "h": 2.33, "k": "H", "port": "Londonderry"}, {"t": "2026-01-02T18:51", "h": 4.4, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-02T19:01", "h": 4.8, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-02T20:45", "h": 0.99, "k": "L", "port": "North Shields"}, {"t": "2026-01-02T21:01", "h": 4.1, "k": "H", "port": "Skirza"}, {"t": "2026-01-02T21:01", "h": 1.01, "k": "L", "port": "Whitby"}, {"t": "2026-01-02T21:15", "h": 1.27, "k": "L", "port": "Scarborough"}, {"t": "2026-01-02T21:46", "h": 0.82, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-02T22:08", "h": 0.94, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-02T22:28", "h": 1.13, "k": "L", "port": "Newlyn"}, {"t": "2026-01-02T22:47", "h": 0.45, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-02T22:49", "h": 0.71, "k": "L", "port": "Bundoran"}, {"t": "2026-01-02T22:49", "h": 0.63, "k": "L", "port": "Cork"}, {"t": "2026-01-02T23:00", "h": 1.11, "k": "L", "port": "Plymouth"}, {"t": "2026-01-02T23:07", "h": 0.69, "k": "L", "port": "Falcarragh"}, {"t": "2026-01-02T23:17", "h": 3.97, "k": "H", "port": "Lossiemouth"}, {"t": "2026-01-02T23:30", "h": 1.45, "k": "L", "port": "Llangennith"}, {"t": "2026-01-02T23:31", "h": -2.58, "k": "L", "port": "MilfordHaven"}, {"t": "2026-01-02T23:41", "h": 2.98, "k": "H", "port": "Campbeltown"}], "sunrise": "2026-01-02T08:20", "sunset": "2026-01-02T16:27"}, "2026-01-03": {"by_port": {"croyde": [{"t": "2026-01-03T00:00", "h": 0.09, "k": "L", "port": "Croyde"}, {"t": "2026-01-03T05:30", "h": 6.83, "k": "H", "port": "Croyde"}, {"t": "2026-01-03T12:31", "h": -0.19, "k": "L", "port": "Croyde"}, {"t": "2026-01-03T17:56", "h": 6.78, "k": "H", "port": "Croyde"}], "stornoway": [{"t": "2026-01-03T00:28", "h": 1.07, "k": "L", "port": "Stornoway"}, {"t": "2026-01-03T06:30", "h": 4.92, "k": "H", "port": "Stornoway"}, {"t": "2026-01-03T13:00", "h": 0.9, "k": "L", "port": "Stornoway"}, {"t": "2026-01-03T18:58", "h": 4.64, "k": "H", "port": "Stornoway"}], "aberdeen": [{"t": "2026-01-03T00:50", "h": 4.26, "k": "H", "port": "Aberdeen"}, {"t": "2026-01-03T06:47", "h": 1.04, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-03T13:06", "h": 4.39, "k": "H", "port": "Aberdeen"}, {"t": "2026-01-03T19:15", "h": 0.69, "k": "L", "port": "Aberdeen"}], "cape wrath": [{"t": "2026-01-03T01:06", "h": 0.97, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-03T07:12", "h": 4.56, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-03T13:34", "h": 0.74, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-03T19:44", "h": 4.48, "k": "H", "port": "Cape Wrath"}], "londonderry": [{"t": "2026-01-03T01:10", "h": 0.46, "k": "L", "port": "Londonderry"}, {"t": "2026-01-03T07:15", "h": 2.58, "k": "H", "port": "Londonderry"}, {"t": "2026-01-03T13:48", "h": 0.45, "k": "L", "port": "Londonderry"}, {"t": "2026-01-03T19:35", "h": 2.35, "k": "H", "port": "Londonderry"}], "aberystwyth": [{"t": "2026-01-03T02:10", "h": 0.89, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-03T07:23", "h": 5.1, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-03T14:41", "h": 0.66, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-03T19:47", "h": 4.91, "k": "H", "port": "Aberystwyth"}], "skirza": [{"t": "2026-01-03T02:29", "h": 1.28, "k": "L", "port": "Skirza"}, {"t": "2026-01-03T09:17", "h": 4.33, "k": "H", "port": "Skirza"}, {"t": "2026-01-03T15:00", "h": 1.02, "k": "L", "port": "Skirza"}, {"t": "2026-01-03T21:54", "h": 4.17, "k": "H", "port": "Skirza"}], "north shields": [{"t": "2026-01-03T02:46", "h": 5.04, "k": "H", "port": "North Shields"}, {"t": "2026-01-03T09:09", "h": 1.12, "k": "L", "port": "North Shields"}, {"t": "2026-01-03T15:07", "h": 5.08, "k": "H", "port": "North Shields"}, {"t": "2026-01-03T21:37", "h": 0.74, "k": "L", "port": "North Shields"}], "whitby": [{"t": "2026-01-03T03:04", "h": 5.36, "k": "H", "port": "Whitby"}, {"t": "2026-01-03T09:24", "h": 1.15, "k": "L", "port": "Whitby"}, {"t": "2026-01-03T15:23", "h": 5.52, "k": "H", "port": "Whitby"}, {"t": "2026-01-03T21:52", "h": 0.77, "k": "L", "port": "Whitby"}], "scarborough": [{"t": "2026-01-03T03:18", "h": 5.46, "k": "H", "port": "Scarborough"}, {"t": "2026-01-03T09:39", "h": 1.39, "k": "L", "port": "Scarborough"}, {"t": "2026-01-03T15:39", "h": 5.51, "k": "H", "port": "Scarborough"}, {"t": "2026-01-03T22:07", "h": 1.0, "k": "L", "port": "Scarborough"}], "newlyn": [{"t": "2026-01-03T04:06", "h": 5.45, "k": "H", "port": "Newlyn"}, {"t": "2026-01-03T11:00", "h": 0.95, "k": "L", "port": "Newlyn"}, {"t": "2026-01-03T16:32", "h": 5.33, "k": "H", "port": "Newlyn"}, {"t": "2026-01-03T23:20", "h": 0.98, "k": "L", "port": "Newlyn"}], "coomeenole": [{"t": "2026-01-03T04:08", "h": 4.17, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-03T10:17", "h": 0.56, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-03T16:40", "h": 4.07, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-03T22:35", "h": 0.73, "k": "L", "port": "Coomeenole"}], "doonbeg": [{"t": "2026-01-03T04:30", "h": 4.7, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-03T10:39", "h": 0.63, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-03T17:03", "h": 4.59, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-03T22:57", "h": 0.84, "k": "L", "port": "Doonbeg"}], "cork": [{"t": "2026-01-03T04:42", "h": 4.16, "k": "H", "port": "Cork"}, {"t": "2026-01-03T11:20", "h": 0.56, "k": "L", "port": "Cork"}, {"t": "2026-01-03T17:06", "h": 4.09, "k": "H", "port": "Cork"}, {"t": "2026-01-03T23:41", "h": 0.49, "k": "L", "port": "Cork"}], "plymouth": [{"t": "2026-01-03T05:07", "h": 5.36, "k": "H", "port": "Plymouth"}, {"t": "2026-01-03T11:30", "h": 0.92, "k": "L", "port": "Plymouth"}, {"t": "2026-01-03T17:38", "h": 5.18, "k": "H", "port": "Plymouth"}, {"t": "2026-01-03T23:49", "h": 0.92, "k": "L", "port": "Plymouth"}], "bundoran": [{"t": "2026-01-03T05:13", "h": 4.02, "k": "H", "port": "Bundoran"}, {"t": "2026-01-03T11:24", "h": 0.59, "k": "L", "port": "Bundoran"}, {"t": "2026-01-03T17:40", "h": 3.79, "k": "H", "port": "Bundoran"}, {"t": "2026-01-03T23:37", "h": 0.6, "k": "L", "port": "Bundoran"}], "campbeltown": [{"t": "2026-01-03T05:14", "h": 0.79, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-03T11:58", "h": 3.13, "k": "H", "port": "Campbeltown"}, {"t": "2026-01-03T17:47", "h": 0.53, "k": "L", "port": "Campbeltown"}], "inishcrone": [{"t": "2026-01-03T05:15", "h": 3.92, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-03T11:20", "h": 0.15, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-03T17:47", "h": 3.7, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-03T23:34", "h": 0.36, "k": "L", "port": "Inishcrone"}], "lossiemouth": [{"t": "2026-01-03T05:18", "h": 0.97, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-03T11:34", "h": 4.12, "k": "H", "port": "Lossiemouth"}, {"t": "2026-01-03T17:47", "h": 0.6, "k": "L", "port": "Lossiemouth"}], "falcarragh": [{"t": "2026-01-03T05:27", "h": 3.94, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-03T11:37", "h": 0.56, "k": "L", "port": "Falcarragh"}, {"t": "2026-01-03T17:53", "h": 3.81, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-03T23:54", "h": 0.55, "k": "L", "port": "Falcarragh"}], "llangennith": [{"t": "2026-01-03T05:39", "h": 8.32, "k": "H", "port": "Llangennith"}, {"t": "2026-01-03T11:59", "h": 1.17, "k": "L", "port": "Llangennith"}, {"t": "2026-01-03T18:06", "h": 8.34, "k": "H", "port": "Llangennith"}], "milfordhaven": [{"t": "2026-01-03T05:39", "h": 3.16, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-03T12:01", "h": -2.79, "k": "L", "port": "MilfordHaven"}, {"t": "2026-01-03T18:05", "h": 3.06, "k": "H", "port": "MilfordHaven"}]}, "ext": [{"t": "2026-01-03T00:00", "h": 0.09, "k": "L", "port": "Croyde"}, {"t": "2026-01-03T00:28", "h": 1.07, "k": "L", "port": "Stornoway"}, {"t": "2026-01-03T00:50", "h": 4.26, "k": "H", "port": "Aberdeen"}, {"t": "2026-01-03T01:06", "h": 0.97, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-03T01:10", "h": 0.46, "k": "L", "port": "Londonderry"}, {"t": "2026-01-03T02:10", "h": 0.89, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-03T02:29", "h": 1.28, "k": "L", "port": "Skirza"}, {"t": "2026-01-03T02:46", "h": 5.04, "k": "H", "port": "North Shields"}, {"t": "2026-01-03T03:04", "h": 5.36, "k": "H", "port": "Whitby"}, {"t": "2026-01-03T03:18", "h": 5.46, "k": "H", "port": "Scarborough"}, {"t": "2026-01-03T04:06", "h": 5.45, "k": "H", "port": "Newlyn"}, {"t": "2026-01-03T04:08", "h": 4.17, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-03T04:30", "h": 4.7, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-03T04:42", "h": 4.16, "k": "H", "port": "Cork"}, {"t": "2026-01-03T05:07", "h": 5.36, "k": "H", "port": "Plymouth"}, {"t": "2026-01-03T05:13", "h": 4.02, "k": "H", "port": "Bundoran"}, {"t": "2026-01-03T05:14", "h": 0.79, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-03T05:15", "h": 3.92, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-03T05:18", "h": 0.97, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-03T05:27", "h": 3.94, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-03T05:30", "h": 6.83, "k": "H", "port": "Croyde"}, {"t": "2026-01-03T05:39", "h": 8.32, "k": "H", "port": "Llangennith"}, {"t": "2026-01-03T05:39", "h": 3.16, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-03T06:30", "h": 4.92, "k": "H", "port": "Stornoway"}, {"t": "2026-01-03T06:47", "h": 1.04, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-03T07:12", "h": 4.56, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-03T07:15", "h": 2.58, "k": "H", "port": "Londonderry"}, {"t": "2026-01-03T07:23", "h": 5.1, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-03T09:09", "h": 1.12, "k": "L", "port": "North Shields"}, {"t": "2026-01-03T09:17", "h": 4.33, "k": "H", "port": "Skirza"}, {"t": "2026-01-03T09:24", "h": 1.15, "k": "L", "port": "Whitby"}, {"t": "2026-01-03T09:39", "h": 1.39, "k": "L", "port": "Scarborough"}, {"t": "2026-01-03T10:17", "h": 0.56, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-03T10:39", "h": 0.63, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-03T11:00", "h": 0.95, "k": "L", "port": "Newlyn"}, {"t": "2026-01-03T11:20", "h": 0.56, "k": "L", "port": "Cork"}, {"t": "2026-01-03T11:20", "h": 0.15, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-03T11:24", "h": 0.59, "k": "L", "port": "Bundoran"}, {"t": "2026-01-03T11:30", "h": 0.92, "k": "L", "port": "Plymouth"}, {"t": "2026-01-03T11:34", "h": 4.12, "k": "H", "port": "Lossiemouth"}, {"t": "2026-01-03T11:37", "h": 0.56, "k": "L", "port": "Falcarragh"}, {"t": "2026-01-03T11:58", "h": 3.13, "k": "H", "port": "Campbeltown"}, {"t": "2026-01-03T11:59", "h": 1.17, "k": "L", "port": "Llangennith"}, {"t": "2026-01-03T12:01", "h": -2.79, "k": "L", "port": "MilfordHaven"}, {"t": "2026-01-03T12:31", "h": -0.19, "k": "L", "port": "Croyde"}, {"t": "2026-01-03T13:00", "h": 0.9, "k": "L", "port": "Stornoway"}, {"t": "2026-01-03T13:06", "h": 4.39, "k": "H", "port": "Aberdeen"}, {"t": "2026-01-03T13:34", "h": 0.74, "k": "L", "port": "Cape Wrath"}, {"t": "2026-01-03T13:48", "h": 0.45, "k": "L", "port": "Londonderry"}, {"t": "2026-01-03T14:41", "h": 0.66, "k": "L", "port": "Aberystwyth"}, {"t": "2026-01-03T15:00", "h": 1.02, "k": "L", "port": "Skirza"}, {"t": "2026-01-03T15:07", "h": 5.08, "k": "H", "port": "North Shields"}, {"t": "2026-01-03T15:23", "h": 5.52, "k": "H", "port": "Whitby"}, {"t": "2026-01-03T15:39", "h": 5.51, "k": "H", "port": "Scarborough"}, {"t": "2026-01-03T16:32", "h": 5.33, "k": "H", "port": "Newlyn"}, {"t": "2026-01-03T16:40", "h": 4.07, "k": "H", "port": "Coomeenole"}, {"t": "2026-01-03T17:03", "h": 4.59, "k": "H", "port": "Doonbeg"}, {"t": "2026-01-03T17:06", "h": 4.09, "k": "H", "port": "Cork"}, {"t": "2026-01-03T17:38", "h": 5.18, "k": "H", "port": "Plymouth"}, {"t": "2026-01-03T17:40", "h": 3.79, "k": "H", "port": "Bundoran"}, {"t": "2026-01-03T17:47", "h": 3.7, "k": "H", "port": "Inishcrone"}, {"t": "2026-01-03T17:47", "h": 0.6, "k": "L", "port": "Lossiemouth"}, {"t": "2026-01-03T17:47", "h": 0.53, "k": "L", "port": "Campbeltown"}, {"t": "2026-01-03T17:53", "h": 3.81, "k": "H", "port": "Falcarragh"}, {"t": "2026-01-03T17:56", "h": 6.78, "k": "H", "port": "Croyde"}, {"t": "2026-01-03T18:05", "h": 3.06, "k": "H", "port": "MilfordHaven"}, {"t": "2026-01-03T18:06", "h": 8.34, "k": "H", "port": "Llangennith"}, {"t": "2026-01-03T18:58", "h": 4.64, "k": "H", "port": "Stornoway"}, {"t": "2026-01-03T19:15", "h": 0.69, "k": "L", "port": "Aberdeen"}, {"t": "2026-01-03T19:35", "h": 2.35, "k": "H", "port": "Londonderry"}, {"t": "2026-01-03T19:44", "h": 4.48, "k": "H", "port": "Cape Wrath"}, {"t": "2026-01-03T19:47", "h": 4.91, "k": "H", "port": "Aberystwyth"}, {"t": "2026-01-03T21:37", "h": 0.74, "k": "L", "port": "North Shields"}, {"t": "2026-01-03T21:52", "h": 0.77, "k": "L", "port": "Whitby"}, {"t": "2026-01-03T21:54", "h": 4.17, "k": "H", "port": "Skirza"}, {"t": "2026-01-03T22:07", "h": 1.0, "k": "L", "port": "Scarborough"}, {"t": "2026-01-03T22:35", "h": 0.73, "k": "L", "port": "Coomeenole"}, {"t": "2026-01-03T22:57", "h": 0.84, "k": "L", "port": "Doonbeg"}, {"t": "2026-01-03T23:20", "h": 0.98, "k": "L", "port": "Newlyn"}, {"t": "2026-01-03T23:34", "h": 0.36, "k": "L", "port": "Inishcrone"}, {"t": "2026-01-03T23:37", "h": 0.6, "k": "L", "port": "Bundoran"}, {"t": "2026-01-03T23:41", "h": 0.49, "k": "L", "port": "Cork"}, {"t": "2026-01-03T23:49", "h": 0.92, "k": "L", "port": "Plymouth"}, {"t": "2026-01-03T23:54", "h": 0.55, "k": "L", "port": "Falcarragh"}], "sunrise": "2026-01-03T08:20", "sunset": "2026-01-03T16:28"}};
</script>
<script>
  window.MOON = {"2026-01-01": {"name": "Waxing Gibbous", "emoji": "\ud83c\udf14", "illumination": 0.907, "age_days": 11.86, "is_spring": false, "is_neap": false}, "2026-01-02": {"name": "Waxing Gibbous", "emoji": "\ud83c\udf14", "illumination": 0.963, "age_days": 12.94, "is_spring": false, "is_neap": false}, "2026-01-03": {"name": "Waxing Gibbous", "emoji": "\ud83c\udf14", "illumination": 0.993, "age_days": 13.96, "is_spring": true, "is_neap": false}, "2026-01-04": {"name": "Full Moon", "emoji": "\ud83c\udf15", "illumination": 0.999, "age_days": 15.04, "is_spring": true, "is_neap": false}};
</script>

<script>
  function dayInfo(offset) {
    const base = new Date(_todayBase);
    base.setDate(base.getDate() + offset);

    const optsPretty = {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      timeZone: 'Europe/London'
    };
    const optsISO = {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      timeZone: 'Europe/London'
    };

    const pretty = base.toLocaleDateString('en-GB', optsPretty);
    const isoParts = base.toLocaleDateString('en-GB', optsISO).split('/');
    const iso = `${isoParts[2]}-${isoParts[1]}-${isoParts[0]}`;

    return { iso, pretty };
  }
</script>

<script>
  // Shim so all existing code that calls dayISO(...) keeps working.
  function dayISO(offset){ return dayInfo(offset).iso; }
</script>



<script>


    function isoForOffset(offset){
    return dayInfo(offset).iso;
    }

  function paintOverview(offset){
    const iso = typeof offset === 'number' ? isoForOffset(offset) : offset;
    const areas = window.REGION_DATA ? Object.keys(window.REGION_DATA) : [];
    if (!areas.length) return;
    const area = areas[0];                         // e.g. "Cornwall"
    const r = window.REGION_DATA[area]?.[iso];
    if (!r) return;

    // Update dial & readouts with averages; pass no colour so we don’t set a ring
    updateDualDial({
      spot_name:    area,
      wind_dir:     r.wind_dir,
      swell_dir:    r.swell_dir,
      wind_speed:   r.wind_speed,     // m/s
      swell_height: r.swell_height,   // m
      swell_period: r.swell_period,   // s
      colour:       ''                // ← empty = no state class applied
    });

    // Make the chip say Overview and clear any prior state class
    const chip = document.getElementById('state-chip');
    if (chip) chip.textContent = 'Overview';
    const box = document.getElementById('dials');
    if (box) box.classList.remove('state-green','state-amber','state-red');
  }
</script>
<script>
  // Recompute best windows from tide_pref on the client, ignoring payload windows
  const RECOMPUTE_WINDOWS_FROM_PREF = true;
</script>

<script>
  // Minimal JS shims that your existing app already expects
  // They intentionally keep the same IDs & semantics as before.

  function sendZoom(direction){
    const iframe = document.getElementById('tv-map');
    iframe?.contentWindow?.postMessage({ zoom: direction }, '*');
  }

  // Friendly date (same logic you used)
  function formatFriendly(d){
    const day=d.getDate();
    const suffix=(day>=11&&day<=13)?'th':({1:'st',2:'nd',3:'rd'}[day%10]||'th');
    const month=d.toLocaleString('en-GB',{month:'long'});
    return `${month} ${day}${suffix}`;
  }



  // Day switcher – just changes iframe source and header meta
const _todayBase = new Date();
let CURRENT_OFFSET = 0;
let ACTIVE_SPOT = null;

    function showSpot(p){
    ACTIVE_SPOT = {...p};
    updateDualDial({
        spot_name:    p.spot_name,
        wind_dir:     p.wind_dir,
        swell_dir:    p.swell_dir,
        wind_speed:   p.wind_speed,
        swell_height: p.swell_height,
        swell_period: p.swell_period,
        colour:       p.colour
    });
    renderTideForDay(dayISO(CURRENT_OFFSET), {
        showNow:  CURRENT_OFFSET === 0,
        windows:  Array.isArray(p.windows) ? p.windows : [],
        colour:   (p.colour || '').toLowerCase(),
        tidePref: p.tide_pref || null,
        station:  (p.tide_port || p.tide_station || null)
    });
    setTidePrefChip(p.tide_pref || null);
    }

    function showOverview(){
    ACTIVE_SPOT = null;
    paintOverview(CURRENT_OFFSET);
    renderTideForDay(dayISO(CURRENT_OFFSET), { showNow: CURRENT_OFFSET === 0 });

    // NEW: hide chip on overview
    setTidePrefChip(null);
    }



  function labelFor(offset){
    if (offset === 0) return 'Today';
    if (offset === 1) return 'Tomorrow';
    return '+2 Days';
  }

    function _normStation(s){ return (s || '').toString().trim().toLowerCase(); }
    function _stationOf(e){
    return _normStation(e && (e.port || e.station || e.source));
    }



  function setHeaderFor(offset){
    // Build “Monday September 29th” in Europe/London
    const base = new Date();
    base.setDate(base.getDate() + offset);

    const weekday = base.toLocaleDateString('en-GB', { weekday: 'long', timeZone: 'Europe/London' });
    const month   = base.toLocaleDateString('en-GB', { month:   'long', timeZone: 'Europe/London' });
    const dayNum  = Number(base.toLocaleDateString('en-GB', { day: '2-digit', timeZone: 'Europe/London' }));

    const suffix = (n)=>{
      if (n>=11 && n<=13) return 'th';
      const s = {1:'st',2:'nd',3:'rd'}[n%10] || 'th';
      return s;
    };

    const dt = document.getElementById('tv-date-text');
    if (dt) dt.textContent = `${weekday} ${month} ${dayNum}${suffix(dayNum)}`;

    // Moon: prefer “tonight” but fall back to same-day if missing
    const isoTonight = dayISO(offset + 1);
    const isoToday   = dayISO(offset);

    const me = document.getElementById('tv-moon-phase');
    let m = null;

    if (window.MOON) {
      if (window.MOON.name) {
        m = window.MOON; // single object shape
      } else {
        m = window.MOON[isoTonight] || window.MOON[isoToday] || null;
      }
    }

    if (me) me.textContent = m ? `${m.emoji || ''} ${m.name || ''}`.trim() : '—';
  }

  const USE_PER_DAY_MAP = true; // ← hard off for now
  function switchDay(offset){
    CURRENT_OFFSET = offset;


  setHeaderFor(offset);
  

    // If a spot is locked, keep showing that spot; otherwise show overview
    if (ACTIVE_SPOT){
      updateDualDial({
        spot_name:    ACTIVE_SPOT.spot_name,
        wind_dir:     ACTIVE_SPOT.wind_dir,
        swell_dir:    ACTIVE_SPOT.swell_dir,
        wind_speed:   ACTIVE_SPOT.wind_speed,
        swell_height: ACTIVE_SPOT.swell_height,
        swell_period: ACTIVE_SPOT.swell_period,
        colour:       ACTIVE_SPOT.colour
      });
      renderTideForDay(dayISO(offset), {
        showNow: offset === 0,
        windows: Array.isArray(ACTIVE_SPOT.windows) ? ACTIVE_SPOT.windows : [],
        colour:  (ACTIVE_SPOT.colour || '').toLowerCase(),
        tidePref: ACTIVE_SPOT.tide_pref || null
      });
      setTidePrefChip(ACTIVE_SPOT.tide_pref || null);

    } else {
      paintOverview(offset);
      renderTideForDay(dayISO(offset), { showNow: offset === 0 });
    }

    // (optional legacy hook)
    if (typeof updateDialsForDay === 'function') {
      updateDialsForDay(isoForOffset(offset));
    }

    // Keep the forecast drawer in sync if it's open
    const box = document.getElementById('forecast-float');
    if (box && !box.hasAttribute('hidden')){
      setActiveForecastTab(offset);
      loadForecastInto(offset, `panel-${offset}`);
    }

    // inside switchDay(offset)
    const isSynoptic = (localStorage.getItem('ui.primaryView') === 'synoptic');

    if (USE_PER_DAY_MAP && !isSynoptic) {
    const bust = Date.now();
    const iframe = document.getElementById('tv-map');
    iframe && (iframe.src = `map_day${offset}.html?v=${bust}`);
    }



  }

  // First load + date pill cycles 0→1→2→0 using ONLY switchDay
  document.addEventListener('DOMContentLoaded', ()=>{
    switchDay(0);             // initial state

    const dateBtn = document.getElementById('tv-date-text');
    dateBtn?.addEventListener('click', ()=>{
      CURRENT_OFFSET = (CURRENT_OFFSET + 1) % 3;
      switchDay(CURRENT_OFFSET);   // no extra paintOverview/renderTide here
    });
  });
</script>

    <script>
    // --- forecast file path



    function forecastPath(dateISO){
    const rel = `rag_lab/output/forecast_${dateISO}.md`; // no leading slash
    return new URL(rel, document.baseURI).href;          // absolute, unambiguous
    }


    // --- cache so we don't re-fetch
    const _forecastCache = new Map();

    // Load one day's forecast into a given panelId
    async function loadForecastInto(offset, panelId){
    const el = document.getElementById(panelId);
    if (!el) return;


    const iso = dayISO(offset);

    if (_forecastCache.has(iso)){
    el.textContent = _forecastCache.get(iso);
    return;
    }
    el.textContent = 'Loading…';
    try{

    const url = `${forecastPath(iso)}?v=${Date.now()}`; // cache-bust per request
    el.dataset.iso = iso;                                // optional: for DevTools inspection
    el.dataset.url = url;

    const res = await fetch(url, { cache:'no-store' });

    if (!res.ok){
    console.warn('Forecast fetch failed', {iso, url, status: res.status});
    }
    const txt = res.ok ? await res.text() : 'No forecast available.';
    _forecastCache.set(iso, txt);
    el.textContent = txt;
    }catch(e){
    console.warn('Forecast fetch error', e);
    el.textContent = 'No forecast available.';
    }
    }

    // Make these callable from inline handlers
    window.loadForecastInto = loadForecastInto;

    // --- open/close from the header chip
    function _toggleForecast(forceOpen){
    const box = document.getElementById('forecast-float');
    const btn = document.getElementById('forecast-toggle');
    const willOpen = (typeof forceOpen === 'boolean') ? forceOpen : box.hasAttribute('hidden');

    if (willOpen){
    box.removeAttribute('hidden');
    btn.textContent = 'Forecast ▴';
    btn.setAttribute('aria-expanded','true');
    setActiveForecastTab(CURRENT_OFFSET);
    loadForecastInto(CURRENT_OFFSET, `panel-${CURRENT_OFFSET}`);
    }else{
    box.setAttribute('hidden','');
    btn.textContent = 'Forecast ▾';
    btn.setAttribute('aria-expanded','false');
    }
    }
    window.toggleForecast = _toggleForecast;   // ← expose globally

    // --- tabs UI
    function setActiveForecastTab(offset){
    [0,1,2].forEach(o=>{
    const tab = document.getElementById(`tab-${o}`);
    const panel = document.getElementById(`panel-${o}`);
    if (!tab || !panel) return;
    const active = (o === offset);
    tab.setAttribute('aria-selected', active ? 'true' : 'false');
    panel.toggleAttribute('hidden', !active);
    });
    }
    window.setActiveForecastTab = setActiveForecastTab; // ← expose globally

    // Clicking tabs also switches the day (keeps everything in sync)
    function onForecastTabClick(e){
    const btn = e.target.closest('.tab');
    if (!btn) return;
    const off = Number(btn.dataset.offset || 0);
    CURRENT_OFFSET = off;
    switchDay(off);
    if (typeof paintOverview === 'function') paintOverview(off);
    setActiveForecastTab(off);
    loadForecastInto(off, `panel-${off}`);
    }

    // --- wire up on first load
    document.addEventListener('DOMContentLoaded', ()=>{
    // preload quietly
    //[0,1,2].forEach(o => loadForecastInto(o, `panel-${o}`));

    // tab clicks
    document.querySelector('.forecast-tabs')?.addEventListener('click', onForecastTabClick);

    // reflect initial hidden state
    const btn = document.getElementById('forecast-toggle');
    if (btn){
    btn.textContent = 'Forecast ▾';
    btn.setAttribute('aria-expanded','false');
    }
    });
    </script>

    <script>
    function setTidePrefChip(pref){
    const el = document.getElementById('tide-pref-chip');
    if (!el) return;
    if (!pref) { el.setAttribute('hidden',''); return; }
    el.textContent = `Tide pref: ${pref}`;
    el.removeAttribute('hidden');
    }
    </script>

    <script>
    /* ========== Drag / persist for DIALS (container-relative & clamped) ========== */
    (function(){
    const box    = document.getElementById('dials');
    const handle = document.getElementById('dials-handle');
    const wrap   = document.querySelector('.map-wrap');
    const iframe = document.getElementById('tv-map');

    // bucket by viewport width so desktop & mobile don't fight
    const vwBucket = Math.round(window.innerWidth / 200) * 200; // e.g. 800, 1000, 1200
    const storeKey = (key) => `${key}.pos.${vwBucket}`;

    if (!box || !handle || !wrap) return;

    // restore saved pos (relative to wrap)
    let saved = JSON.parse(localStorage.getItem(storeKey('dials')) || 'null');
    if (!saved) {
        // one-time migration from legacy key
        const legacy = JSON.parse(localStorage.getItem('dials.pos') || 'null');
        if (legacy) {
        saved = legacy;
        localStorage.setItem(storeKey('dials'), JSON.stringify(legacy));
        localStorage.removeItem('dials.pos');
        }
    }






    if (saved && Number.isFinite(saved.top) && Number.isFinite(saved.left)) {
        box.style.top  = saved.top  + 'px';
        box.style.left = saved.left + 'px';
        box.style.transform = 'none';
    }

    function clampToWrap() {
        const wr = wrap.getBoundingClientRect();
        const br = box.getBoundingClientRect();
        const maxTop  = Math.max(0, wr.height - br.height);
        const maxLeft = Math.max(0, wr.width  - br.width);
        const curTop  = parseFloat(box.style.top  || '0');
        const curLeft = parseFloat(box.style.left || '0');
        box.style.top  = Math.max(0, Math.min(curTop,  maxTop))  + 'px';
        box.style.left = Math.max(0, Math.min(curLeft, maxLeft)) + 'px';
    }
    clampToWrap();

    let startX=0, startY=0, startTop=0, startLeft=0, dragging=false;

    function onDown(e){
        dragging = true;
        const p = (e.touches && e.touches[0]) || e;
        startX = p.clientX; startY = p.clientY;
        // measure offsets relative to wrap
        const br = box.getBoundingClientRect();
        const wr = wrap.getBoundingClientRect();
        startTop  = br.top  - wr.top;
        startLeft = br.left - wr.left;
        if (iframe) iframe.style.pointerEvents = 'none'; // let mousemove reach the page
        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', onMove, {passive:false});
        document.addEventListener('mouseup', onUp);
        document.addEventListener('touchend', onUp);
    }

    function onMove(e){
        if (!dragging) return;
        const p = (e.touches && e.touches[0]) || e;
        const dx = p.clientX - startX;
        const dy = p.clientY - startY;
        const wr = wrap.getBoundingClientRect();
        const br = box.getBoundingClientRect();
        const maxTop  = wr.height - br.height;
        const maxLeft = wr.width  - br.width;
        const top  = Math.max(0, Math.min(startTop  + dy, maxTop));
        const left = Math.max(0, Math.min(startLeft + dx, maxLeft));
        box.style.top  = top  + 'px';
        box.style.left = left + 'px';
        e.preventDefault?.();
    }

    function onUp(){
        dragging = false;
        if (iframe) iframe.style.pointerEvents = 'auto';
        // save relative to wrap
        const br = box.getBoundingClientRect();
        const wr = wrap.getBoundingClientRect();
        localStorage.setItem(storeKey('dials'), JSON.stringify({
            top:  br.top  - wr.top,
            left: br.left - wr.left
        }));
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('mouseup', onUp);
        document.removeEventListener('touchend', onUp);
    }

    handle.addEventListener('mousedown', onDown);
    handle.addEventListener('touchstart', onDown, {passive:true});
    window.addEventListener('resize', clampToWrap);
    })();
    </script>









    <script>


    /* ========== Helpers for the new SVG dial ========== */
    function toCardinal(deg){
    if (deg == null || isNaN(deg)) return '--';
    const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
    const i = Math.round(((deg % 360)+360)%360 / 22.5) % 16;
    return dirs[i];
    }

    // Place a chevron on the circumference pointing inward.
    function placeChevron(gEl, dirDeg, radius = 105){
    if (!gEl || dirDeg == null || isNaN(dirDeg)) return;
    const theta = ((dirDeg % 360) + 360) % 360; // 0° = N (top)
    // rotate to bearing, move to rim, then flip 180° so it points inward
    gEl.setAttribute('transform', `rotate(${theta}) translate(0, -${radius}) rotate(180)`);
    }

    // Update chevrons, readouts, and state chip/title
    function updateDualDial({ spot_name, wind_dir, swell_dir, wind_speed, swell_height, swell_period, colour }){
    // <- different radii so they never overlap
    placeChevron(document.getElementById('chev-wind'),  wind_dir, 100); // inner
    placeChevron(document.getElementById('chev-swell'), swell_dir, 108); // outer

    const mph  = Math.round((wind_speed  || 0) * 2.236936);
    const hift = Math.round(((swell_height || 0) * 3.28084) / 1.5);
    const per  = Math.round(swell_period || 0);

    const nbsp = '\u00A0';            // classic non-breaking space
    const rw = document.getElementById('ro-wind');
    const rs = document.getElementById('ro-swell');
    const rp = document.getElementById('ro-period');


    setMiniChevron(wind_dir,  'ro-wind-icon');
    setMiniChevron(swell_dir, 'ro-swell-icon');

    if (rw) rw.textContent = `${toCardinal(wind_dir)} ${Number.isFinite(mph) ? mph : '--'}${nbsp}mph`;
    if (rs) rs.textContent = `${toCardinal(swell_dir)} ${Number.isFinite(hift) ? hift : '–'}${nbsp}ft`;
    if (rp) rp.textContent = Number.isFinite(per) ? `${per}${nbsp}s` : `–${nbsp}s`;

    const title = document.getElementById('hud-title');
    if (title && spot_name) title.textContent = spot_name;

    const box = document.getElementById('dials');
    const chip = document.getElementById('state-chip');
    if (box){
        box.classList.remove('state-green','state-amber','state-red');
        const c = (colour||'').toLowerCase();
        if (c==='green' || c==='amber' || c==='red') box.classList.add(`state-${c}`);
    }
    if (chip){
        let label = 'Working';
        const c = (colour||'').toLowerCase();
        if (c==='green') label = 'Sweet';
        else if (c==='red') label = 'Not happening';
        chip.textContent = label;
    }
    }



    // Map → HUD: update dial AND tide windows
    (() => {
    // remember the last station we rendered so unhover doesn’t revert to “all ports”
    let LAST_TIDE_STATION = null;
    let LAST_TIDE_PREF    = null;

    // Map → HUD: preview on hover, lock on click, don’t revert while locked
    window.addEventListener('message', (event) => {
        const msg = event.data || {};
        const p = msg.payload;

        // Normalise a few click-ish names + allow a lock flag
        const isClick =
        msg.type === 'spotClick' ||
        msg.type === 'spotSelect' ||
        msg.type === 'spotFocus' ||
        msg.type === 'spotChosen' ||
        msg.clicked === true ||
        msg.lock === true ||
        (p && (p.clicked === true || p.lock === true));

        // 1) Lock to a spot (click/select)
        if (isClick && p) {
        // make sure showSpot/render get the port
        if (!p.tide_port && p.tide_station) p.tide_port = p.tide_station;
        LAST_TIDE_STATION = (p.tide_port || '').trim() || null;
        LAST_TIDE_PREF    = (p.tide_pref || null);

        showSpot(p); // your function; ensure it passes p.tide_port to renderTideForDay (see note below)
        return;
        }

        // 2) Hover preview (only when not locked)
        if (msg.type === 'spotHover' && p && !ACTIVE_SPOT) {
        // cache the station from the map payload
        const station = (p.tide_port || p.tide_station || '').trim() || null;
        LAST_TIDE_STATION = station;
        LAST_TIDE_PREF    = (p.tide_pref || null);

        updateDualDial({
            spot_name:    p.spot_name,
            wind_dir:     p.wind_dir,
            swell_dir:    p.swell_dir,
            wind_speed:   p.wind_speed,
            swell_height: p.swell_height,
            swell_period: p.swell_period,
            colour:       p.colour
        });

        renderTideForDay(dayISO(CURRENT_OFFSET), {
            showNow:  CURRENT_OFFSET === 0,
            windows:  Array.isArray(p.windows) ? p.windows : [],
            colour:   (p.colour || '').toLowerCase(),
            tidePref: p.tide_pref || null,
            station:  station                  // ← crucial
        });

        // preview chip on hover (only when not locked)
        setTidePrefChip(p.tide_pref || null);
        return;
        }

        // 3) Unhover → only revert if nothing is locked
        if (msg.type === 'spotUnhover' && !ACTIVE_SPOT) {
        // keep the last port’s curve rather than reverting to merged list
        if (LAST_TIDE_STATION) {
            renderTideForDay(dayISO(CURRENT_OFFSET), {
            showNow:  CURRENT_OFFSET === 0,
            tidePref: LAST_TIDE_PREF,
            station:  LAST_TIDE_STATION
            });
            setTidePrefChip(LAST_TIDE_PREF || null);
        } else {
            showOverview();
        }
        return;
        }

        // 4) Clear/reset from the map
        if (msg.type === 'clearSelection' || msg.type === 'mapReset') {
        LAST_TIDE_STATION = null;
        showOverview();
        return;
        }
    }, false);
    })();


    </script>


    <script>
    // Map → Nav: when a spot is clicked, sync the dropdowns
    window.addEventListener('message', (ev) => {
      const { type, payload } = ev.data || {};

      if (type === 'spotClick') {
        lockedPayload = payload;
        setHudFromPayload(payload);   // update chip + forecast
        if (payload?.country_code) {
          // 🔒 update dropdowns and save permanently
          setDropdownsSilent(payload.country_code, payload.area);
          try {
            localStorage.setItem('navSelection_v1', JSON.stringify({
              country: payload.country_code,
              area: payload.area || 'ALL'
            }));
          } catch(_) {}
        }
      }
    });
    </script>




    <script>
    function buildTicks16(){
    const g = document.getElementById('ticks16');
    if (!g) return;
    const SVG = 'http://www.w3.org/2000/svg';
    for (let i=0;i<16;i++){
        const major = (i % 4 === 0);
        const mid   = (i % 2 === 0) && !major;
        const len   = major ? 14 : mid ? 10 : 6;     // long, medium, short
        const r1 = 100, r2 = r1 + len;
        const a  = i * 22.5 * Math.PI / 180;         // 0° = N
        const x1 =  r1 * Math.sin(a), y1 = -r1 * Math.cos(a);
        const x2 =  r2 * Math.sin(a), y2 = -r2 * Math.cos(a);
        const line = document.createElementNS(SVG,'line');
        line.setAttribute('x1', x1); line.setAttribute('y1', y1);
        line.setAttribute('x2', x2); line.setAttribute('y2', y2);
        line.setAttribute('stroke', '#c7c7c7');
        line.setAttribute('stroke-width', major ? 3 : 2);
        g.appendChild(line);
    }
    }
    document.addEventListener('DOMContentLoaded', buildTicks16);
    </script>



    <script>
    // rotate an inline mini chevron so 0° = N, 90° = E
    function setMiniChevron(dirDeg, elId){
    const el = document.getElementById(elId);
    if (!el || dirDeg == null || isNaN(dirDeg)) return;
    const theta = ((dirDeg % 360) + 360) % 360;
    // show direction of travel, not source → add 180°
    el.style.transform = `rotate(${(theta + 180) % 360}deg)`;
    }
    </script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
    // your existing first-run setup
    // (you already call switchDay(0) earlier — that’s fine)

    // Paint the regional overview immediately
    if (window.REGION_DEFAULT) {
        updateDualDial(window.REGION_DEFAULT);

        const chip = document.getElementById('state-chip');
        if (chip) chip.textContent = 'Overview';

        const box = document.getElementById('dials');
        if (box){
        box.classList.remove('state-green','state-amber','state-red');
        const c = (REGION_DEFAULT.colour || 'amber').toLowerCase();
        box.classList.add(`state-${c}`);
        }
    }
    });
    </script>


    <script>
    // Compute one shared Y-scale from the three tab days
    function tideScaleForTabs(){
    const days = [dayISO(0), dayISO(1), dayISO(2)];
    let min = Infinity, max = -Infinity;

    days.forEach(d => {
        const exts = (window.TIDES?.[d]?.ext) || [];
        exts.forEach(e => {
        const h = e.h;
        if (Number.isFinite(h)) {
            if (h < min) min = h;
            if (h > max) max = h;
        }
        });
    });

    // sensible fallback if data is thin
    if (!isFinite(min) || !isFinite(max) || min === max) { min = 0; max = 5; }

    // small visual padding
    const pad = (max - min) * 0.15;
    return [min - pad, max + pad];
    }
    </script>

    <script>
    function _parseISO(s){ return new Date(s); }
    
    function _isoHM(d){
    // build a local ISO (no Z) so it aligns with dayStart/dayEnd and the SVG renderer
    const pad = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }



    function _extStitched(iso){
    const day = new Date(iso + 'T12:00:00');
    const yIso = new Date(day.getTime() - 86400000).toISOString().slice(0,10);
    const nIso = new Date(day.getTime() + 86400000).toISOString().slice(0,10);
    const y = (window.TIDES?.[yIso]?.ext || []).map(e => ({...e, _t:_parseISO(e.t)}));
    const t = (window.TIDES?.[iso ]?.ext || []).map(e => ({...e, _t:_parseISO(e.t)}));
    const n = (window.TIDES?.[nIso]?.ext || []).map(e => ({...e, _t:_parseISO(e.t)}));
    const all = [...y, ...t, ...n].sort((a,b)=>a._t - b._t);
    return { all, todayOnly: t };
    }

    function _subtractIntervals(dayStart, dayEnd, forb){
    const S = dayStart.getTime(), E = dayEnd.getTime();
    const bad = forb
        .map(([s,e]) => [Math.max(S, +s), Math.min(E, +e)])
        .filter(([s,e]) => e > s)
        .sort((a,b)=>a[0]-b[0]);

    const merged = [];
    for (const seg of bad){
        if (!merged.length || seg[0] > merged[merged.length-1][1]) merged.push(seg);
        else merged[merged.length-1][1] = Math.max(merged[merged.length-1][1], seg[1]);
    }

    const good = [];
    let cur = S;
    for (const [bs,be] of merged){
        if (bs > cur) good.push([cur, bs]);
        cur = Math.max(cur, be);
    }
    if (cur < E) good.push([cur, E]);
    return good.map(([s,e]) => [new Date(s), new Date(e)]);
    }

    // Build tide windows from the already-filtered extrema list (local Dates).
    // Returns an array of [Date, Date] pairs in LOCAL time (no ISO/UTC roundtrips).
    function computeWindowsForPrefFromExt(iso, tidePref, extList){
    if (!tidePref || !Array.isArray(extList) || !extList.length) return [];

    const pref = String(tidePref).toUpperCase().replace(' ONLY', '');
    const dayStart = new Date(iso + 'T00:00:00');
    const dayEnd   = new Date(iso + 'T23:59:59');

    const MINS = m => m * 60 * 1000;

    // Tunables (minutes)
    const PAD_ONLY   = 60;   // HIGH ONLY / LOW ONLY  ±1h
    const PAD_MID_1  = 60;   // MID TIDE: start  +1h
    const PAD_MID_2  = 120;  // MID TIDE: end    +2h
    const PAD_BLOCK  = 45;   // NOT HIGH/NOT LOW: blackout half-width
    const PAD_ALL    = 120;  // ALL: show a generous band around each extremum

    // Helpers --------------------------------------------------------------
    const highs = [], lows = [];
    for (const e of extList) {
        const k = String(e.k || '').toUpperCase();
        const t = new Date(e.t);
        if (k === 'H') highs.push(t);
        else if (k === 'L') lows.push(t);
    }

    const clip = (s, e) => {
        const S = Math.max(dayStart.getTime(), s.getTime());
        const E = Math.min(dayEnd.getTime(),   e.getTime());
        return E > S ? [new Date(S), new Date(E)] : null;
    };

    const around = (ts, padMins) =>
        ts.map(t => clip(new Date(t.getTime() - MINS(padMins)),
                        new Date(t.getTime() + MINS(padMins))))
        .filter(Boolean);

    const merge = (intervals) => {
        if (!intervals.length) return [];
        const iv = intervals.slice().sort((a,b)=>a[0]-b[0]);
        const out = [iv[0]];
        for (let i=1;i<iv.length;i++){
        const [s,e] = iv[i], last = out[out.length-1];
        if (s <= last[1]) last[1] = new Date(Math.max(last[1], e));
        else out.push([s,e]);
        }
        return out;
    };

    // base minus a set of “cuts” intervals
    const subtract = (base, cuts) => {
        if (!base) return [];
        if (!cuts.length) return [base];
        const [B0, B1] = base;
        const inDay = cuts
        .map(c => clip(c[0], c[1]))
        .filter(Boolean)
        .sort((a,b)=>a[0]-b[0]);

        if (!inDay.length) return [base];

        const result = [];
        let cur = B0;
        for (const [cs, ce] of inDay){
        if (cs > cur) result.push([cur, new Date(cs)]);
        if (ce > cur) cur = new Date(Math.max(cur, ce));
        }
        if (cur < B1) result.push([cur, B1]);
        return result;
    };

    // Preferences ----------------------------------------------------------
    let wins = [];
    switch (pref) {
        case 'ALL': {
        // Full day; the renderer will clip to daylight. No gaps at mid-tide.
        wins = [[dayStart, dayEnd]];
        break;
        }
        case 'HIGH': {
        wins = merge(around(highs, PAD_ONLY));
        break;
        }
        case 'LOW': {
        wins = merge(around(lows, PAD_ONLY));
        break;
        }
        case 'MID TIDE': {
        const mids = [];
        for (const t of highs.concat(lows)) {
            const s = new Date(t.getTime() + MINS(PAD_MID_1));
            const e = new Date(t.getTime() + MINS(PAD_MID_2));
            const iv = clip(s, e);
            if (iv) mids.push(iv);
        }
        wins = merge(mids);
        break;
        }
        case 'NOT HIGH': {
        const blocks = around(highs, PAD_BLOCK);
        wins = subtract([dayStart, dayEnd], blocks);
        wins = merge(wins);
        break;
        }
        case 'NOT LOW': {
        const blocks = around(lows, PAD_BLOCK);
        wins = subtract([dayStart, dayEnd], blocks);
        wins = merge(wins);
        break;
        }
        default: {
        // Unknown label → be safe: just return whole day (drawer will clip to daylight)
        wins = [[dayStart, dayEnd]];
        }
    }
    return wins;
    }


    function computeWindowsForPref(iso, tidePref){
    if (!tidePref) return [];
    const pref = String(tidePref).trim().toUpperCase();

    // Map "HIGH ONLY" -> "HIGH", "LOW ONLY" -> "LOW"
    const norm = pref.replace(/\s+ONLY\b/, '');

    const dayStart = new Date(iso + 'T00:00:00');
    const dayEnd   = new Date(iso + 'T23:59:59');

    const { todayOnly } = _extStitched(iso);
    if (!todayOnly.length) return [];

    const mins = (m)=> m*60*1000;

    // Tunables (make PAD_NOT = PAD_HILO if you want exact complement)
    const PAD_HILO = 55; // ±55 min near H/L for HIGH/LOW( ONLY )
    const PAD_NOT  = 45; // ±45 min excluded for NOT HIGH/LOW

    function around(kind, padMins){
        return todayOnly
        .filter(e => e.k === kind)
        .map(e => [new Date(e._t.getTime()-mins(padMins)),
                    new Date(e._t.getTime()+mins(padMins))])
        .map(([s,e]) => [_isoHM(s), _isoHM(e)]);
    }

    if (norm === 'HIGH' || norm === 'HIGH TIDE') return around('H', PAD_HILO);
    if (norm === 'LOW'  || norm === 'LOW TIDE')  return around('L', PAD_HILO);

    if (norm === 'NOT HIGH'){
        const forb = todayOnly
        .filter(e => e.k === 'H')
        .map(e => [new Date(e._t.getTime()-mins(PAD_NOT)),
                    new Date(e._t.getTime()+mins(PAD_NOT))]);
        return _subtractIntervals(dayStart, dayEnd, forb).map(([s,e]) => [_isoHM(s), _isoHM(e)]);
    }

    if (norm === 'NOT LOW'){
        const forb = todayOnly
        .filter(e => e.k === 'L')
        .map(e => [new Date(e._t.getTime()-mins(PAD_NOT)),
                    new Date(e._t.getTime()+mins(PAD_NOT))]);
        return _subtractIntervals(dayStart, dayEnd, forb).map(([s,e]) => [_isoHM(s), _isoHM(e)]);
    }

    if (norm === 'MID' || norm === 'MID TIDE'){
        const forb = todayOnly
        .filter(e => e.k === 'H' || e.k === 'L')
        .map(e => [new Date(e._t.getTime()-mins(PAD_HILO)),
                    new Date(e._t.getTime()+mins(PAD_HILO))]);
        return _subtractIntervals(dayStart, dayEnd, forb).map(([s,e]) => [_isoHM(s), _isoHM(e)]);
    }

    if (norm === 'ALL' || norm === 'ALWAYS' || norm === 'ANY'){
        return [[ _isoHM(dayStart), _isoHM(dayEnd) ]];
    }

    return [];
    }

    </script>






    <script>
    // ---------- Tide SVG renderer (cosine interpolation with day-to-day stitching) ----------

    function renderTideForDay(iso, {showNow=false, windows=[], colour='', tidePref=null, station=null} = {}){

    let __LAST_TIDE_RENDER_KEY = null;
    const box = document.getElementById('tide-svg');
    if (!box) return;
    while (box.firstChild) box.removeChild(box.firstChild);
    console.log('[tide] tzOffset(min)=', new Date().getTimezoneOffset());
    // --- single-port tide selection (defensive) ---
    const data = (window.TIDES && window.TIDES[iso]) || {};
    const want = (station || '').trim().toLowerCase();

    const _normPortKey = s => String(s || '').trim().toLowerCase().replace(/\s+/g, '');

    let todayExt = [];

    // 1) Prefer grouped by_port if present (exact or relaxed match)
    if (data.by_port && want) {
        if (data.by_port[want]) {
        todayExt = data.by_port[want].slice();
        } else {
        const relaxed = _normPortKey(want);
        const foundKey = Object.keys(data.by_port).find(k => _normPortKey(k) === relaxed);
        if (foundKey) todayExt = data.by_port[foundKey].slice();
        }
    }

    // 2) Fallback: legacy flat list (filter by .port/.station)
    if (!todayExt.length && Array.isArray(data.ext)) {
        todayExt = want
        ? data.ext.filter(e => _normPortKey(e.port || e.station || e.source) === _normPortKey(want))
        : data.ext.slice();
    }

    // 3) Final guard: if mixed ports slipped through, keep only one
    if (todayExt.length) {
        const counts = {};
        for (const e of todayExt) {
        const k = _normPortKey(e.port || e.station || e.source);
        counts[k] = (counts[k] || 0) + 1;
        }
        let primary = _normPortKey(want);
        if (!primary || !counts[primary]) {
        primary = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
        }
        const before = todayExt.length;
        todayExt = todayExt.filter(e => _normPortKey(e.port || e.station || e.source) === primary);

        console.log('[tide] iso=', iso,
                    'want=', want,
                    'portsAvailable=', (data.by_port ? Object.keys(data.by_port) : []),
                    'portsInList=', Object.keys(counts),
                    'chosen=', primary,
                    'kept=', todayExt.length, 'of', before);
    }

    if (!todayExt.length) {
        console.warn('[tide] no extrema for', iso, 'want=', want, data);
        return;
    }


    // --- DEBUG A: show the extrema (H/L) we are about to use for window calc ---
    (function debugExtrema(){
    try {
        const norm = s => String(s||'').trim();
        const rowsH = todayExt
        .filter(e => (e.k || '').toUpperCase() === 'H')
        .map(e => ({
            kind: 'H',
            time: new Date(e.t).toTimeString().slice(0,5),
            iso:  String(e.t),
            port: norm(e.port || e.station || e.source),
            h:    e.h
        }));
        const rowsL = todayExt
        .filter(e => (e.k || '').toUpperCase() === 'L')
        .map(e => ({
            kind: 'L',
            time: new Date(e.t).toTimeString().slice(0,5),
            iso:  String(e.t),
            port: norm(e.port || e.station || e.source),
            h:    e.h
        }));

        console.groupCollapsed(
        '[tide/debug A] extrema for', iso,
        '| station=', (want || '(auto)')
        );
        console.log(`H count=${rowsH.length}  L count=${rowsL.length}  pref=${tidePref || '(none)'}`);
        console.table([...rowsH, ...rowsL]);
        if (!rowsH.length && String(tidePref).toUpperCase()==='NOT HIGH') {
        console.warn('[tide/debug A] NOT HIGH requested but no highs for this station/day');
        }
        if (!rowsL.length && String(tidePref).toUpperCase()==='NOT LOW') {
        console.warn('[tide/debug A] NOT LOW requested but no lows for this station/day');
        }
        console.groupEnd();
    } catch (err) {
        console.warn('[tide/debug A] failed:', err);
    }
    })();

    // --- derive windows from the selected port’s extrema (ignore any pre-baked windows) ---
    let windowsFromPref = [];
    if (tidePref) {
    windowsFromPref = computeWindowsForPrefFromExt(iso, tidePref, todayExt); // [[Date,Date], ...]
    }
    windows = tidePref ? windowsFromPref : (Array.isArray(windows) ? windows : []);

    // --- windows: recompute using the FILTERED extrema for this station ---
    // --- windows: recompute using the FILTERED extrema for this station ---
    const RECOMPUTE_WINDOWS_FROM_PREF = true;
    const pref = tidePref ? String(tidePref).toUpperCase() : null;

    // Keep windows as Date pairs in LOCAL time (no ISO string roundtrip!)
    const _pairsToLocalDates = pairs =>
    pairs.map(([s, e]) => [new Date(s), new Date(e)]);

    if (pref) {
    const winPairs = computeWindowsForPrefFromExt(iso, pref, todayExt); // [[Date,Date], ...]
    windows = RECOMPUTE_WINDOWS_FROM_PREF
        ? _pairsToLocalDates(winPairs)                       // always override
        : (Array.isArray(windows) && windows.length
            ? windows
            : _pairsToLocalDates(winPairs));
    } else if (Array.isArray(windows) && windows.length && typeof windows[0] === 'string') {
    // Caller passed "start~end" strings → convert to Date pairs once
    windows = windows.map(w => {
        const [sStr, eStr] = String(w).split('~');
        return [new Date(sStr), new Date(eStr)];
    });
    } else if (!Array.isArray(windows)) {
    windows = [];
    }

    // --- DEBUG B: show the exact windows that will be drawn (pre-clip) ---
    (function debugWindows(){
    try {
        const rows = (Array.isArray(windows) ? windows : []).map((w,i) => {
        let sStr, eStr;
        if (Array.isArray(w) && w.length === 2) {
            [sStr, eStr] = w;
        } else {
            [sStr, eStr] = String(w).split('~');
        }
        const fmt = d => new Date(d).toTimeString().slice(0,5);
        return { i, startISO: String(sStr), endISO: String(eStr), start: fmt(sStr), end: fmt(eStr) };
        });
        console.groupCollapsed(
        '[tide/debug B] windows for', iso,
        '| station=', (want || '(auto)'),
        '| pref=', (pref || '(none)')
        );
        console.log('window count =', rows.length);
        console.table(rows);
        console.groupEnd();
    } catch (err) {
        console.warn('[tide/debug B] failed:', err);
    }
    })();

    const SVGNS = 'http://www.w3.org/2000/svg';
    const W=320, H=84, PADL=28, PADR=6, PADT=6, PADB=18;
    const innerW = W-PADL-PADR, innerH = H-PADT-PADB;

    const parse = (s)=> new Date(s);
    const toIso = (d)=> d.toISOString().slice(0,10);
    const t0 = new Date(iso + 'T00:00:00');
    const t1 = new Date(iso + 'T23:59:59');

    const sunrise = data.sunrise ? parse(data.sunrise) : null;
    const sunset  = data.sunset  ? parse(data.sunset)  : null;

    // ——— stitch yesterday/tomorrow ———

    const dIso = new Date(iso + 'T12:00:00');
    const yIso = toIso(new Date(dIso.getTime() - 86400000));
    const nIso = toIso(new Date(dIso.getTime() + 86400000));

    const normKey = _normPortKey; // you already defined this above

    function extremaForDayPort(dayIso, wantKey) {
    const d = (window.TIDES && window.TIDES[dayIso]) || {};
    // prefer grouped by_port
    if (d.by_port) {
        // exact or relaxed key match
        if (d.by_port[wantKey]) return d.by_port[wantKey].map(e => ({...e, _t: parse(e.t)}));
        const relaxed = Object.keys(d.by_port).find(k => normKey(k) === wantKey);
        if (relaxed) return d.by_port[relaxed].map(e => ({...e, _t: parse(e.t)}));
    }
    // legacy flat list fallback
    const list = Array.isArray(d.ext) ? d.ext : [];
    return list
        .filter(e => normKey(e.port || e.station || e.source) === wantKey)
        .map(e => ({...e, _t: parse(e.t)}));
    }

    // use the same chosen station key we already resolved for todayExt
    const chosenKey =
    todayExt.length
        ? normKey(todayExt[0].port || todayExt[0].station || todayExt[0].source)
        : normKey(want); // defensive

    const yExt = extremaForDayPort(yIso, chosenKey).sort((a,b)=>a._t - b._t);
    const tExt = todayExt.map(e => ({...e, _t: parse(e.t)})).sort((a,b)=>a._t - b._t);
    const nExt = extremaForDayPort(nIso, chosenKey).sort((a,b)=>a._t - b._t);

    // stitched list using the *same port* on all three days
    const all = [...yExt, ...tExt, ...nExt];

    // (keep your ghost end-caps as-is)
    if (all.length >= 2) {
    const first   = all[0], second = all[1];
    const preSpan = Math.max(1, second._t - first._t);
    all.unshift({ _t: new Date(first._t.getTime() - preSpan), h: second.h, k: second.k, _ghost: true });

    const last    = all[all.length - 1], prev = all[all.length - 2];
    const postSpan = Math.max(1, last._t - prev._t);
    all.push({ _t: new Date(last._t.getTime() + postSpan), h: prev.h, k: prev.k, _ghost: true });
    }


    const [hmin, hmax] = tideScaleForTabs();

    const xOf = (d)=> {
        const u = (d - t0) / (t1 - t0);
        return PADL + Math.max(0, Math.min(1, u)) * innerW;
    };
    const yOf = (h)=> {
        const u = (h - hmin) / (hmax - hmin);
        return PADT + (1-Math.max(0, Math.min(1, u))) * innerH;
    };

    // --- shading layers (drawn bottom → top): night, past, axis/curve ---

    // 1) Night blocks: [00:00 → sunrise] and [sunset → 24:00]
    if (sunrise && sunset){
    const xSR = xOf(sunrise);
    const xSS = xOf(sunset);

    // before sunrise
    if (xSR > PADL) {
        const n1 = document.createElementNS(SVGNS,'rect');
        n1.setAttribute('x', PADL);
        n1.setAttribute('y', PADT);
        n1.setAttribute('width', xSR - PADL);
        n1.setAttribute('height', innerH);
        n1.setAttribute('class','tide--night');
        box.appendChild(n1);
    }

    // after sunset
    if (xSS < PADL + innerW) {
        const n2 = document.createElementNS(SVGNS,'rect');
        n2.setAttribute('x', xSS);
        n2.setAttribute('y', PADT);
        n2.setAttribute('width', (PADL + innerW) - xSS);
        n2.setAttribute('height', innerH);
        n2.setAttribute('class','tide--night');
        box.appendChild(n2);
    }
    }

    // 2) Past overlay: [00:00 → now], only for “today”
    if (showNow){
    const now = new Date();
    if (now.toISOString().slice(0,10) === iso){
        const xNow = Math.max(PADL, Math.min(PADL + innerW, xOf(now)));
        if (xNow > PADL){
        const p = document.createElementNS(SVGNS,'rect');
        p.setAttribute('x', PADL);
        p.setAttribute('y', PADT);
        p.setAttribute('width', xNow - PADL);
        p.setAttribute('height', innerH);
        p.setAttribute('class','tide--past');
        box.appendChild(p);
        }
    }
    }



    // --- best-window overlays (clip to [00:00,24:00] and to daylight) ---
    // --- best-window overlays (clip to [00:00,24:00] and to daylight) ---
    (function drawWindows(){
    if (!Array.isArray(windows) || !windows.length) return;
    if ((colour || '').toLowerCase() === 'red') return;  // don't show for red

    const startOfDay = t0.getTime();
    const endOfDay   = t1.getTime();
    const sr = sunrise ? sunrise.getTime() : startOfDay;
    const ss = sunset  ? sunset.getTime()  : endOfDay;

    function clipInterval(a, b){
        let s = Math.max(a, sr, startOfDay);
        let e = Math.min(b, ss, endOfDay);
        return (e > s) ? [s, e] : null;
    }

        windows.forEach(w => {
        let sDt, eDt;
        if (Array.isArray(w) && w.length === 2) {
            sDt = (w[0] instanceof Date) ? w[0] : new Date(w[0]);
            eDt = (w[1] instanceof Date) ? w[1] : new Date(w[1]);
        } else {
            const [sStr, eStr] = String(w).split('~');
            if (!sStr || !eStr) return;
            sDt = new Date(sStr);
            eDt = new Date(eStr);
        }

        const s = sDt.getTime();
        const e = eDt.getTime();
        const clipped = clipInterval(s, e);
        if (!clipped) return;

        const [cs, ce] = clipped;
        const x0 = xOf(new Date(cs));
        const x1 = xOf(new Date(ce));
        const wpx = x1 - x0;
        if (wpx <= 1) return;

        // 1) The subtle fill
        const rect = document.createElementNS(SVGNS, 'rect');
        rect.setAttribute('x', x0);
        rect.setAttribute('y', PADT);
        rect.setAttribute('width', wpx);
        rect.setAttribute('height', innerH);
        rect.setAttribute('class', `tide--window ${colour==='amber' ? 'amber' : 'green'}`);
        box.appendChild(rect);

        // 2) Strong vertical edges (drawn after the rect so they sit on top)
        const edgeClass = `tide--windowEdge ${colour==='amber' ? 'amber' : 'green'}`;
        const e1 = document.createElementNS(SVGNS, 'line');
        e1.setAttribute('x1', x0); e1.setAttribute('x2', x0);
        e1.setAttribute('y1', PADT); e1.setAttribute('y2', PADT+innerH);
        e1.setAttribute('class', edgeClass);
        box.appendChild(e1);

        const e2 = document.createElementNS(SVGNS, 'line');
        e2.setAttribute('x1', x1); e2.setAttribute('x2', x1);
        e2.setAttribute('y1', PADT); e2.setAttribute('y2', PADT+innerH);
        e2.setAttribute('class', edgeClass);
        box.appendChild(e2);
    });
    })();






    // x-axis
    const axis = document.createElementNS(SVGNS,'line');
    axis.setAttribute('x1', PADL);
    axis.setAttribute('x2', PADL+innerW);
    axis.setAttribute('y1', PADT+innerH);
    axis.setAttribute('y2', PADT+innerH);
    axis.setAttribute('class','tide--axis');
    box.appendChild(axis);

    // ---- NEW: time ticks/labels every 6 hours ----
    // ---- time ticks/labels every 6 hours, incl. 24:00 ----
    const stepHrs = 6; // 00, 06, 12, 18, 24
    for (let h = 0; h <= 24; h += stepHrs) {
    const t = new Date(t0.getTime() + h * 60 * 60 * 1000);
    const x = xOf(t);

    const tick = document.createElementNS(SVGNS, 'line');
    tick.setAttribute('x1', x);
    tick.setAttribute('x2', x);
    tick.setAttribute('y1', PADT + innerH);
    tick.setAttribute('y2', PADT + innerH - 4);
    tick.setAttribute('class', 'tide--tick');
    box.appendChild(tick);

    const lab = document.createElementNS(SVGNS, 'text');
    lab.setAttribute('y', PADT + innerH + 12);
    lab.setAttribute('class', 'tide--tickLabel');

    if (h === 0) {
        // left edge label centred
        lab.setAttribute('x', x);
        lab.setAttribute('text-anchor', 'middle');
        lab.textContent = '00:00';
        box.appendChild(lab);
    } else if (h === 24) {
        // right edge label tucked to the inside so it doesn’t clip
        lab.setAttribute('x', x - 1);         // tiny nudge left
        lab.setAttribute('text-anchor', 'end');
        lab.textContent = '24:00';
        box.appendChild(lab);
    } else {
        lab.setAttribute('x', x);
        lab.setAttribute('text-anchor', 'middle');
        lab.textContent = String(h).padStart(2, '0') + ':00';
        box.appendChild(lab);
    }
    }

    // cosine interpolation using extended extrema
    function hAt(t){
    if (!all.length) return 0;
    if (all.length === 1) return all[0].h;

    const T = t.getTime ? t.getTime() : +t;
    // find the interval [idx, idx+1] that contains or is just left of T
    let idx = 0;
    for (let i = 0; i < all.length - 1; i++){
        const A = all[i]._t.getTime();
        const B = all[i+1]._t.getTime();
        if (T >= A && T <= B) { idx = i; break; }
        if (T >  B) idx = i;
    }
    // clamp to a real segment
    idx = Math.min(idx, all.length - 2);
    const L = all[idx], R = all[idx+1];
    const a = L._t.getTime(), b = R._t.getTime();
    const u = (b === a) ? 0 : Math.max(0, Math.min(1, (T - a) / (b - a)));
    const w = (1 - Math.cos(Math.PI * u)) / 2;
    return (1 - w) * L.h + w * R.h;
    }

    // sample every 10 minutes within the day
    const pts = [];
    for (let t=new Date(t0); t<=t1; t=new Date(t.getTime()+10*60*1000)){
        pts.push([ xOf(t), yOf(hAt(t)) ]);
    }

    // area
    const d = [
        `M ${PADL} ${PADT+innerH}`,
        `L ${pts[0][0]} ${pts[0][1]}`,
        ...pts.slice(1).map(p=>`L ${p[0]} ${p[1]}`),
        `L ${PADL+innerW} ${PADT+innerH}`,
        'Z'
    ].join(' ');
    const area = document.createElementNS(SVGNS,'path');
    area.setAttribute('d', d);
    area.setAttribute('class','tide--water');
    box.appendChild(area);

    // H/L marks (for this day only)
    const todaysOnly = all.filter(e => e._t >= t0 && e._t <= t1);
    todaysOnly.forEach(e=>{
        const cx = xOf(e._t), cy = yOf(e.h);
        const dot = document.createElementNS(SVGNS,'circle');
        dot.setAttribute('cx', cx); dot.setAttribute('cy', cy); dot.setAttribute('r', 3);
        dot.setAttribute('class', e.k === 'H' ? 'tide--markH' : 'tide--markL');
        box.appendChild(dot);

        // ----- smart label placement (handles both H and L, with edge + vertical safety) -----
        const label = document.createElementNS(SVGNS,'text');

        const EDGE_PAD   = 6;                 // inner padding from plot edges
        const SIDE_EAGER = 28;                // switch to “left of dot” a bit earlier near right edge
        const RIGHT_X    = PADL + innerW;

        // Base text
        const txt = `${e.k} ${String(e.h).replace(/\.0$/,'')}m`;

        // Horizontal placement
        let lx = cx + 6;          // default: nudge right of the dot
        let anchor = 'start';     // left-aligned text (grows to the right)

        // If we’re close to the right edge, tuck label to the left of the dot
        if (cx > RIGHT_X - SIDE_EAGER) {
        lx = cx - 6;
        anchor = 'end';         // right-aligned (grows to the left)
        } else if (cx < PADL + SIDE_EAGER) {
        // Near the left edge: keep right-of-dot but ensure it’s inside
        lx = Math.max(PADL + EDGE_PAD, cx + 6);
        anchor = 'start';
        }

        // Final horizontal clamp for safety
        lx = Math.max(PADL + EDGE_PAD, Math.min(RIGHT_X - EDGE_PAD, lx));

        // Vertical placement:
        // - Highs go ABOVE the dot
        // - Lows go BELOW the dot (but flip above if too near the bottom)
        const TOP_Y    = PADT + EDGE_PAD;
        const BOTTOM_Y = PADT + innerH - EDGE_PAD;

        let ly = (e.k === 'H') ? (cy - 6) : (cy + 12);

        // If a low label would fall below the card, flip it above the dot
        if (e.k === 'L' && ly > BOTTOM_Y) {
        ly = cy - 6;
        }
        // If a high label would sit too high (rare), push it below
        if (e.k === 'H' && ly < TOP_Y) {
        ly = cy + 12;
        }

        // Final vertical clamp
        ly = Math.max(TOP_Y, Math.min(BOTTOM_Y, ly));

        // Paint label
        label.setAttribute('x', lx);
        label.setAttribute('y', ly);
        label.setAttribute('class','tide--label');
        label.setAttribute('text-anchor', anchor);
        label.textContent = txt;
        box.appendChild(label);

        try {
        const bb = label.getBBox();

        // spills off the right?
        if (bb.x + bb.width > RIGHT_X - EDGE_PAD) {
            anchor = 'end';
            lx = Math.min(RIGHT_X - EDGE_PAD, cx - 4);
            label.setAttribute('text-anchor', anchor);
            label.setAttribute('x', lx);
        }

        // spills off the left?
        if (bb.x < PADL + EDGE_PAD) {
            anchor = 'start';
            lx = Math.max(PADL + EDGE_PAD, cx + 4);
            label.setAttribute('text-anchor', anchor);
            label.setAttribute('x', lx);
        }
        } catch (e2) {
        // fallback: earlier switch near the edge
        if (cx > RIGHT_X - 36) {
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('x', Math.min(RIGHT_X - EDGE_PAD, cx - 4));
        }
        }


    });

    // “now” cursor (for Today)
    if (showNow){
        const now = new Date();
        if (now.toISOString().slice(0,10) === iso){
        const x = xOf(now);
        const line = document.createElementNS(SVGNS,'line');
        line.setAttribute('x1', x); line.setAttribute('x2', x);
        line.setAttribute('y1', PADT); line.setAttribute('y2', PADT+innerH);
        line.setAttribute('class','tide--axis');
        box.appendChild(line);
        }
    }
    }
    </script>

    <script>
    /* ========== Drag / persist for FORECAST (container-relative & clamped) ========== */
    (function(){
    const box    = document.getElementById('forecast-float');
    const handle = document.getElementById('forecast-handle');
    const wrap   = document.querySelector('.map-wrap');
    const iframe = document.getElementById('tv-map');

    const vwBucket = Math.round(window.innerWidth / 200) * 200;
    const storeKey = (key) => `${key}.pos.${vwBucket}`;
    if (!box || !handle || !wrap) return;

    // We’ll position via left/top, so kill the CSS 'right' so it doesn’t fight us
    box.style.right = 'auto';

    // restore saved pos (relative to wrap)

    let saved = JSON.parse(localStorage.getItem(storeKey('forecast')) || 'null');
    if (!saved) {
    const legacy = JSON.parse(localStorage.getItem('forecast.pos') || 'null');
    if (legacy) {
        saved = legacy;
        localStorage.setItem(storeKey('forecast'), JSON.stringify(legacy));
        localStorage.removeItem('forecast.pos');
    }
    }

    // Normalise possible legacy "right"-based saves
    if (saved && Number.isFinite(saved.top) && (Number.isFinite(saved.left) || Number.isFinite(saved.right))) {
    const wr = wrap.getBoundingClientRect();
    const br = box.getBoundingClientRect();

    const leftPx = Number.isFinite(saved.left)
        ? saved.left
        : Math.max(0, wr.width - (saved.right || 0) - br.width); // convert right→left

    box.style.top  = saved.top  + 'px';
    box.style.left = leftPx     + 'px';

    // ensure it's inside after any viewport change
    clampToWrap();
    }
    function clampToWrap() {
        const wr = wrap.getBoundingClientRect();
        const br = box.getBoundingClientRect();
        const maxTop  = Math.max(0, wr.height - br.height);
        const maxLeft = Math.max(0, wr.width  - br.width);
        const curTop  = parseFloat(box.style.top  || '0');
        const curLeft = parseFloat(box.style.left || '0');
        box.style.top  = Math.max(0, Math.min(curTop,  maxTop))  + 'px';
        box.style.left = Math.max(0, Math.min(curLeft, maxLeft)) + 'px';
    }
    clampToWrap();

    let startX=0, startY=0, startTop=0, startLeft=0, dragging=false;

    function onDown(e){
        dragging = true;
        const p = (e.touches && e.touches[0]) || e;
        startX = p.clientX; startY = p.clientY;
        // offsets relative to wrap
        const br = box.getBoundingClientRect();
        const wr = wrap.getBoundingClientRect();
        startTop  = br.top  - wr.top;
        startLeft = br.left - wr.left;
        if (iframe) iframe.style.pointerEvents = 'none';
        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', onMove, {passive:false});
        document.addEventListener('mouseup', onUp);
        document.addEventListener('touchend', onUp);
    }

    function onMove(e){
        if (!dragging) return;
        const p = (e.touches && e.touches[0]) || e;
        const dx = p.clientX - startX;
        const dy = p.clientY - startY;
        const wr = wrap.getBoundingClientRect();
        const br = box.getBoundingClientRect();
        const maxTop  = wr.height - br.height;
        const maxLeft = wr.width  - br.width;
        const top  = Math.max(0, Math.min(startTop  + dy, maxTop));
        const left = Math.max(0, Math.min(startLeft + dx, maxLeft));
        box.style.top  = top  + 'px';
        box.style.left = left + 'px';
        e.preventDefault?.();
    }

    function onUp(){
        dragging = false;
        if (iframe) iframe.style.pointerEvents = 'auto';
        // save relative to wrap
        const br = box.getBoundingClientRect();
        const wr = wrap.getBoundingClientRect();

        localStorage.setItem(storeKey('forecast'), JSON.stringify({
            top:  br.top  - wr.top,
            left: br.left - wr.left
        }));


        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('mouseup', onUp);
        document.removeEventListener('touchend', onUp);
    }

    handle.addEventListener('mousedown', onDown);
    handle.addEventListener('touchstart', onDown, {passive:true});
    window.addEventListener('resize', clampToWrap);
    })();
    </script>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
        const root = document.documentElement;
        const header = document.querySelector('.header');

        function applyHeaderHeight(){
            const h = header ? header.offsetHeight : 64;
            root.style.setProperty('--headerH', h + 'px');
        }

        applyHeaderHeight();
        window.addEventListener('resize', applyHeaderHeight);
        });
    </script>

    <script>
    (function(){
    const vwBucket = Math.round(window.innerWidth / 200) * 200;
    const storeKey = (key) => `${key}.size.${vwBucket}`;

    function makeResizable(
        boxId,
        key,
        { minW=260, minH=160, maxW=1200, maxH=900, onlyW=false } = {}
    ){
        const box = document.getElementById(boxId);
        if (!box) return;
        const handle = box.querySelector('.resize-handle');
        if (!handle) return;

        // restore saved size
        try{
        const saved = JSON.parse(localStorage.getItem(storeKey(key)) || 'null');
        if (saved && Number.isFinite(saved.w)) {
            box.style.width = Math.max(minW, Math.min(saved.w, maxW)) + 'px';
        }
        if (!onlyW && saved && Number.isFinite(saved.h)) {
            box.style.height = Math.max(minH, Math.min(saved.h, maxH)) + 'px';
        } else if (onlyW) {
            // let height be auto for the dials box so contents flow
            box.style.height = 'auto';
        }
        }catch{}

        let startX=0, startY=0, startW=0, startH=0, resizing=false;

        function onDown(e){
        const p = (e.touches && e.touches[0]) || e;
        resizing = true;
        startX = p.clientX; startY = p.clientY;
        const cs = getComputedStyle(box);
        startW = parseFloat(cs.width)  || box.offsetWidth;
        startH = parseFloat(cs.height) || box.offsetHeight;
        document.body.style.userSelect = 'none';
        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', onMove, {passive:false});
        document.addEventListener('mouseup', onUp);
        document.addEventListener('touchend', onUp);
        e.preventDefault?.();
        }

        function onMove(e){
        if (!resizing) return;
        const p = (e.touches && e.touches[0]) || e;
        const dx = p.clientX - startX;
        const dy = p.clientY - startY;

        const w = Math.max(minW, Math.min(startW + dx, maxW));
        box.style.width = w + 'px';

        if (!onlyW){
            const h = Math.max(minH, Math.min(startH + dy, maxH));
            box.style.height = h + 'px';
        } else {
            // keep height auto for dials so inner pieces reflow naturally
            box.style.height = 'auto';
        }
        e.preventDefault?.();
        }

        function onUp(){
        if (!resizing) return;
        resizing = false;

        // save what changed
        const w = Math.round(parseFloat(getComputedStyle(box).width)  || box.offsetWidth);
        const h = Math.round(parseFloat(getComputedStyle(box).height) || box.offsetHeight);
        const payload = onlyW ? { w } : { w, h };
        localStorage.setItem(storeKey(key), JSON.stringify(payload));

        // cleanup
        document.body.style.userSelect = '';
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('mouseup', onUp);
        document.removeEventListener('touchend', onUp);
        }

        handle.addEventListener('mousedown', onDown);
        handle.addEventListener('touchstart', onDown, {passive:true});
    }

        document.addEventListener('DOMContentLoaded', ()=>{
        const isPhone = window.matchMedia('(max-width: 520px)').matches;

        // DIALS: width-only; allow smaller min on phones
        makeResizable('dials','dials',{
            minW: isPhone ? 200 : 280,
            maxW: 700,
            onlyW: true
        });

        // FORECAST: width + height; optionally loosen mins on phones
        makeResizable('forecast-float','forecast',{
            minW: isPhone ? 200 : 280,
            minH: isPhone ? 160 : 200,
            maxW: 1100,
            maxH: 1000,
            onlyW: false
        });
        });
    })();
    </script>


    <script>
    (() => {
    const IFRAME = document.getElementById('tv-map');
    const BTN    = document.getElementById('synoptic-toggle');
    const KEY    = 'ui.primaryView';               // 'synoptic' | 'spoton'
    //const SYN_URL = 'synoptic.html';
    //const SYN_URL = 'synoptic_movie_test.html';
    const SYN_URL = 'https://synoptic.spoton.tips/synoptic_movie_test.html';
    const MAP_URL = () => `map_day${window.CURRENT_OFFSET || 0}.html`;

    let PRIMARY_VIEW = (localStorage.getItem(KEY) === 'synoptic') ? 'synoptic' : 'spoton';

    // NEW: small helper to fade during swaps (prevents the visible re-render)
    function swapIframe(url){
        if (!IFRAME) return;
        IFRAME.style.opacity = '0';                  // hide current doc immediately
        const onLoad = () => { IFRAME.style.opacity = '1'; };
        IFRAME.addEventListener('load', onLoad, { once:true });
        IFRAME.setAttribute('src', url);
    }


    // Early catcher in case iframe posts before initNav attaches its listener
    window.__mapReadyFlag = false;
    window.addEventListener('message', (ev) => {
      const d = ev.data || {};
      if (d.type === 'mapReady') window.__mapReadyFlag = true;
    });

    // --- add these near the top of the parent script ---
    let __mapReady = false;
    let __lastPendingNav = null;

    function reflectButton() {
    if (!BTN) return;
    const isSyn = PRIMARY_VIEW === 'synoptic';

    // Label shows the destination (reads like a toggle)
    BTN.textContent = isSyn ? 'Spot-On ▾' : 'Gales ▾';

    // (optional) keep the tooltip accurate
    BTN.title = isSyn ? 'Show Spot On map' : 'Show or hide gale warnings';

    BTN.setAttribute('aria-pressed', isSyn ? 'true' : 'false');
    }

    function loadIframeIfNeeded() {
        if (!IFRAME) return;

        // desired path for the current primary view
        //const wantPath = PRIMARY_VIEW === 'synoptic'
        //? 'synoptic.html'
        //: `map_day${window.CURRENT_OFFSET || 0}.html`;

        const wantPath = PRIMARY_VIEW === 'synoptic'
           ? SYN_URL
           : `map_day${window.CURRENT_OFFSET || 0}.html`;

        // current iframe path (compare by pathname only)
        const haveURL  = new URL(IFRAME.getAttribute('src') || '', document.baseURI);
        const havePath = haveURL.pathname.replace(/^\//,'');  // strip leading slash for compare

        // if we already have a map_day*.html and want map, do nothing (even if ?v differs)
        if (PRIMARY_VIEW === 'spoton' && /map_day\d+\.html$/i.test(havePath)) return;

        // if path already matches desired view, do nothing
        if (havePath.endsWith(wantPath)) return;

        // CHANGE: use swapIframe (fade) instead of direct setAttribute
        swapIframe(wantPath);
    }

    // The only setter for this state
    window.setPrimaryView = function(view) {
    const v = (view === 'synoptic') ? 'synoptic' : 'spoton';
    if (v === PRIMARY_VIEW) return;

    PRIMARY_VIEW = v;
    localStorage.setItem(KEY, v);
    reflectButton();          // update UI immediately
    loadIframeIfNeeded();     // then (maybe) swap the iframe

    // ⬇️ Keep Country/Area dropdowns sensible for each view
    try {
        if (v === 'synoptic') {                // Gales view
        if (!window.__lastSpotSel && window.navGetSelection) {
            window.__lastSpotSel = window.navGetSelection();  // snapshot current
        }
        if (window.navSetCountryArea) window.navSetCountryArea('NEA', ''); // force NE Atlantic
        } else {                               // Spot-On view
        if (window.__lastSpotSel && window.navSetCountryArea) {
            const { country, area } = window.__lastSpotSel;
            window.navSetCountryArea(country || 'GB', area || 'ALL');        // restore previous
        }
        window.__lastSpotSel = null;
        }
    } catch (e) { console.warn('[nav sync]', e); }

    window.dispatchEvent(new CustomEvent('primaryviewchange', { detail: { view: v }}));
    };

    document.addEventListener('DOMContentLoaded', () => {
        reflectButton();
    });

    // Clicking the chip toggles
    BTN?.addEventListener('click', () => {
        setPrimaryView(PRIMARY_VIEW === 'synoptic' ? 'spoton' : 'synoptic');
    });

    // Initial paint
    reflectButton();
    loadIframeIfNeeded();       // won’t stomp if already correct
    })();
    </script>


    <script>
    // --- What’s Up show/hide
    function toggleDials(forceOpen){
        const box = document.getElementById('dials');
        const btn = document.getElementById('dials-toggle');
        if (!box || !btn) return;

        const willOpen = (typeof forceOpen === 'boolean')
        ? forceOpen
        : box.hasAttribute('hidden'); // hidden → opening

        if (willOpen){
        box.removeAttribute('hidden');
        btn.textContent = 'What’s Up ▴';
        btn.setAttribute('aria-pressed','true');
        localStorage.setItem('dials.visible','1');
        } else {
        box.setAttribute('hidden','');
        btn.textContent = 'What’s Up ▾';
        btn.setAttribute('aria-pressed','false');
        localStorage.setItem('dials.visible','0');
        }
    }
    window.toggleDials = toggleDials;

    // restore last choice on load (default = hidden)
    document.addEventListener('DOMContentLoaded', ()=>{
        const vis = localStorage.getItem('dials.visible');
        if (vis === '1') {
        toggleDials(true);
        } else {
        toggleDials(false); // default hidden
        }
    });
    </script>





    <script>
    /* ========= Drag + resize like the other panels ========= */
    (function(){
    const box    = document.getElementById('synoptic-float');
    const handle = document.getElementById('synoptic-handle');
    const wrap   = document.querySelector('.map-wrap');
    const iframe = document.getElementById('tv-map');
    if (!box || !handle || !wrap) return;

    // Drag (same pattern as others)
    const vwBucket = Math.round(window.innerWidth / 200) * 200;
    const posKey = (k)=> `${k}.pos.${vwBucket}`;
    const sizeKey= (k)=> `${k}.size.${vwBucket}`;
    let saved = JSON.parse(localStorage.getItem(posKey('synoptic')) || 'null');
    if (saved && Number.isFinite(saved.top) && Number.isFinite(saved.left)){
        box.style.top = saved.top + 'px';
        box.style.left= saved.left + 'px';
        box.style.transform = 'none';
    }

    function clamp(){
        const wr = wrap.getBoundingClientRect();
        const br = box.getBoundingClientRect();
        const maxTop  = Math.max(0, wr.height - br.height);
        const maxLeft = Math.max(0, wr.width  - br.width);
        const curTop  = parseFloat(box.style.top  || '0');
        const curLeft = parseFloat(box.style.left || '0');
        box.style.top  = Math.max(0, Math.min(curTop,  maxTop))  + 'px';
        box.style.left = Math.max(0, Math.min(curLeft, maxLeft)) + 'px';
    }
    clamp();

    let sx=0, sy=0, st=0, sl=0, dragging=false;
    function onDown(e){
        dragging=true;
        const p=(e.touches && e.touches[0])||e;
        sx=p.clientX; sy=p.clientY;
        const br=box.getBoundingClientRect(), wr=wrap.getBoundingClientRect();

        // If we’re still using CSS centering (transform), convert it to pixels once.
        if (getComputedStyle(box).transform !== 'none') {
            box.style.left = (br.left - wr.left) + 'px';
            box.style.transform = 'none';
  }

        st=br.top-wr.top; sl=br.left-wr.left;
        if (iframe) iframe.style.pointerEvents='none';
        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', onMove, {passive:false});
        document.addEventListener('mouseup', onUp);
        document.addEventListener('touchend', onUp);
    }
    function onMove(e){
        if (!dragging) return;
        const p=(e.touches && e.touches[0])||e;
        const dx=p.clientX-sx, dy=p.clientY-sy;
        const wr=wrap.getBoundingClientRect(), br=box.getBoundingClientRect();
        const top = Math.max(0, Math.min(st+dy, wr.height-br.height));
        const left= Math.max(0, Math.min(sl+dx, wr.width -br.width ));
        box.style.top = top + 'px';
        box.style.left= left+ 'px';
        e.preventDefault?.();
    }
    function onUp(){
        dragging=false;
        if (iframe) iframe.style.pointerEvents='auto';
        const br=box.getBoundingClientRect(), wr=wrap.getBoundingClientRect();
        localStorage.setItem(posKey('synoptic'), JSON.stringify({ top: br.top-wr.top, left: br.left-wr.left }));
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('mouseup', onUp);
        document.removeEventListener('touchend', onUp);
    }
    handle.addEventListener('mousedown', onDown);
    handle.addEventListener('touchstart', onDown, {passive:true});
    window.addEventListener('resize', clamp);

    // Resize (width-only is usually enough here)
    const storeKey = (key)=> sizeKey(key);
    const rh = box.querySelector('.resize-handle');
    if (rh){
        // restore size
        try{
        const savedS = JSON.parse(localStorage.getItem(storeKey('synoptic')) || 'null');
        if (savedS && Number.isFinite(savedS.w)){
            box.style.width = Math.max(260, Math.min(savedS.w, 1100)) + 'px';
        }
        }catch{}
        let startX=0, startW=0, resizing=false;
        function onRDown(e){
        const p=(e.touches && e.touches[0])||e;
        resizing=true; startX=p.clientX;
        startW=parseFloat(getComputedStyle(box).width)||box.offsetWidth;
        document.body.style.userSelect='none';
        document.addEventListener('mousemove', onRMove);
        document.addEventListener('touchmove', onRMove, {passive:false});
        document.addEventListener('mouseup', onRUp);
        document.addEventListener('touchend', onRUp);
        e.preventDefault?.();
        }
        function onRMove(e){
        if (!resizing) return;
        const p=(e.touches && e.touches[0])||e;
        const dx=p.clientX-startX;
        const w=Math.max(260, Math.min(startW+dx, 1100));
        box.style.width = w + 'px';
        e.preventDefault?.();
        }
        function onRUp(){
        if (!resizing) return;
        resizing=false; document.body.style.userSelect='';
        const w=Math.round(parseFloat(getComputedStyle(box).width)||box.offsetWidth);
        localStorage.setItem(storeKey('synoptic'), JSON.stringify({ w }));
        document.removeEventListener('mousemove', onRMove);
        document.removeEventListener('touchmove', onRMove);
        document.removeEventListener('mouseup', onRUp);
        document.removeEventListener('touchend', onRUp);
        }
        rh.addEventListener('mousedown', onRDown);
        rh.addEventListener('touchstart', onRDown, {passive:true});
    }
    })();
    </script>

    <script>
    async function setSynopticTitle(source, url){
    const title = document.getElementById('synoptic-title');
    if (!title) {
        console.warn("[synoptic] #synoptic-title not found in DOM");
        return;   // 👈 Guard to avoid the null.textContent crash
    }

    const fmt = (d)=> d.toLocaleString('en-GB', {
        timeZone: 'UTC',
        hour12: false,
        year: 'numeric', month: 'short', day: '2-digit',
        hour: '2-digit', minute: '2-digit'
    }) + ' UTC';

    let when = null;
    try {
        const res = await fetch(url, { method: 'HEAD', cache: 'no-store' });
        const lm = res.headers.get('Last-Modified');
        if (lm) when = new Date(lm);
    } catch(_) {}

    title.textContent = `${source} — ${when ? fmt(when) : fmt(new Date())}`;
    }
    </script>




    <script>
    const SF_URL = 'https://raw.githubusercontent.com/Bryan701701/spoton-synoptic/main/shipping_forecast_latest.json';

    // Reword the verbose "For the period ..." string to the compact style we want
    function formatValid(raw){
        if (!raw) return '';
        // e.g. "For the period 06:00 (UTC) on Tue 26 Aug 2025 to 06:00 (UTC) on Wed 27 Aug 2025"
        let t = raw.replace(/^For the period\s*/i,'').replace(/\(UTC\)/gi,'UTC');
        // Replace the middle "to" with an arrow
        t = t.replace(/\s+to\s+/i, ' → ');
        // Shorten any long day/month names if they appear
        t = t.replace(/\bMonday\b/,'Mon')
            .replace(/\bTuesday\b/,'Tue')
            .replace(/\bWednesday\b/,'Wed')
            .replace(/\bThursday\b/,'Thu')
            .replace(/\bFriday\b/,'Fri')
            .replace(/\bSaturday\b/,'Sat')
            .replace(/\bSunday\b/,'Sun')
            .replace(/\bJanuary\b/,'Jan')
            .replace(/\bFebruary\b/,'Feb')
            .replace(/\bMarch\b/,'Mar')
            .replace(/\bApril\b/,'Apr')
            .replace(/\bAugust\b/,'Aug')
            .replace(/\bSeptember\b/,'Sep')
            .replace(/\bOctober\b/,'Oct')
            .replace(/\bNovember\b/,'Nov')
            .replace(/\bDecember\b/,'Dec');
        return 'Valid ' + t;
    }

    async function loadShippingForecast(){
        try{
        const res = await fetch(SF_URL, {cache:'no-store'});
        if(!res.ok) throw new Error('fetch failed');
        const j = await res.json();

        // Only synopsis + valid (no issued)
        const syn   = (j.general_synopsis || '').trim();
        const valid = (j.valid  || '').trim();

        const elSyn   = document.getElementById('syn-synopsis');
        const elValid = document.getElementById('syn-valid');

        if (elSyn)   elSyn.textContent   = syn;
        if (elValid) elValid.textContent = formatValid(valid);

        // show bands only if we have at least one of them
        const hasAny = !!(syn || valid);
        document.getElementById('syn-top')?.toggleAttribute('hidden', !hasAny);
        document.getElementById('syn-bot')?.toggleAttribute('hidden', !hasAny);
        }catch(e){
        // hide on error
        document.getElementById('syn-top')?.setAttribute('hidden','');
        document.getElementById('syn-bot')?.setAttribute('hidden','');
        console.warn('Shipping forecast load failed', e);
        }
    }

















    // helper to toggle bands on source switch
    function showBands(on){
        document.getElementById('syn-top')?.toggleAttribute('hidden', !on);
        document.getElementById('syn-bot')?.toggleAttribute('hidden', !on);
    }

    // Patch your existing source switchers
    (function(){
        const panel = document.getElementById('synoptic-float');
        const elM   = document.getElementById('synoptic-meteosat');
        const elN   = document.getElementById('synoptic-noaa');
        const btnM  = document.getElementById('src-meteosat');
        const btnN  = document.getElementById('src-noaa');
        const METEO_URL = 'https://raw.githubusercontent.com/Bryan701701/spoton-synoptic/main/atlantic_focus.png';
        const NOAA_URL  = 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/FD/GEOCOLOR/latest.jpg';

        // Remove the redundant status label if it exists
        const dupStatus = document.getElementById('synoptic-status');
        if (dupStatus && dupStatus.parentElement) dupStatus.parentElement.removeChild(dupStatus);

        async function showMeteosat(){
        elM?.classList.add('is-active'); elN?.classList.remove('is-active');
        if (elM) elM.src = METEO_URL + '?v=' + Date.now();
        showBands(true);
        await loadShippingForecast();
        setSynopticTitle?.('Meteosat (EUMETSAT)', METEO_URL);
        }

        function showNOAA(){
        elN?.classList.add('is-active'); elM?.classList.remove('is-active');
        if (elN) elN.src = NOAA_URL; // no cache-bust
        showBands(false);
        setSynopticTitle?.('NOAA GOES-16 GeoColor', NOAA_URL);
        }

        btnM?.addEventListener('click', showMeteosat);
        btnN?.addEventListener('click', showNOAA);

        // If panel opens while Meteosat is selected, refresh + load forecast
        const _toggle = window.toggleSynoptic;
        window.toggleSynoptic = function(forceOpen){
        _toggle?.(forceOpen);
        const open = !panel.hasAttribute('hidden');
        if (open){
            const meteosatActive = elM?.classList.contains('is-active');
            meteosatActive ? showMeteosat() : showNOAA();
        }
        };

        // First paint (respect which image is active)
        if (elM?.classList.contains('is-active')) showMeteosat(); else showNOAA();
    })();
    </script>


    <script>
    (function(){
    const MIN_SPLIT_W = 1200;            // threshold for the column layout
    const ROOT = document.body;

    function applySplit(){
        const wide   = window.innerWidth >= MIN_SPLIT_W;
        const view   = localStorage.getItem('ui.primaryView') || 'spoton';
        if (view === 'spoton' && wide) ROOT.classList.add('layout-split');
        else                           ROOT.classList.remove('layout-split');
    }

    // run on load + resize
    window.addEventListener('DOMContentLoaded', applySplit);
    window.addEventListener('resize', applySplit);

    // patch your existing setter so switching views re-checks layout
    window.addEventListener('primaryviewchange', () => applySplit());
    })();
    </script>

    <script>
    (function(){
    // --- state keys
    const k = {
        dials:     'dials.visible',
        forecast:  'forecast.visible',
        primary:   'ui.primaryView',
    };

    // apply saved visibility to DOM
    function applyPanelVisibility(){
    const dials    = document.getElementById('dials');
    const forecast = document.getElementById('forecast-float');

    const isSyn = (localStorage.getItem('ui.primaryView') === 'synoptic');

    // Remember the user's preference the moment we leave Spot-On
    if (dials && !isSyn) {
        const want = localStorage.getItem('dials.visible') === '1';
        dials.toggleAttribute('hidden', !want);
    } else if (dials && isSyn) {
        // Force-hide on Synoptic, without overwriting the remembered preference
        dials.setAttribute('hidden','');
    }

    // Forecast follows the saved choice as before
    const forOn = localStorage.getItem('forecast.visible') === '1';
    forecast && forecast.toggleAttribute('hidden', !forOn);
    }

    // wrap your existing toggles so they update storage
    const _toggleDials     = window.toggleDials;
    const _toggleForecast  = window.toggleForecast;

    window.toggleDials = function(forceOpen){
        _toggleDials?.(forceOpen);
        const dials = document.getElementById('dials');
        localStorage.setItem(k.dials, dials && !dials.hasAttribute('hidden') ? '1' : '0');
    };

    window.toggleForecast = function(forceOpen){
        _toggleForecast?.(forceOpen);
        const box = document.getElementById('forecast-float');
        localStorage.setItem(k.forecast, box && !box.hasAttribute('hidden') ? '1' : '0');
    };

    // re-apply after any view switch (this fixes “click Spot-On → forecast gone”)
    window.addEventListener('primaryviewchange', () => {
    applyPanelVisibility();
    // do the “after frame” tasks once, without nesting setTimeouts everywhere
    requestAnimationFrame(() => {
        applyPanelVisibility();
        window.dispatchEvent(new Event('resize'));
        normalizePanelsForSplit?.();
    });
    });

    // first load – respect previous choice
    window.addEventListener('DOMContentLoaded', applyPanelVisibility);

    // export so section 2 can call it
    window.applyPanelVisibility = applyPanelVisibility;
    })();
    </script>  

    <script>
    function normalizePanelsForSplit(){
    if (!document.body.classList.contains('layout-split')) return;
    ['dials','forecast-float'].forEach(id=>{
        const el = document.getElementById(id);
        if (!el) return;
        el.style.top = el.style.left = el.style.right = el.style.bottom = '';
        el.style.transform = 'none';
        el.style.width = '';   // let CSS/grid size them
        el.style.height = '';  // "
    });
    }
    </script>



    <script>
    // Safe fallback if the original isn't defined yet
    if (typeof window.toggleForecast !== 'function'){
    window.toggleForecast = function(forceOpen){
        const box = document.getElementById('forecast-float');
        if (!box) return;
        const willOpen = (typeof forceOpen === 'boolean') ? forceOpen : box.hasAttribute('hidden');
        if (willOpen){ box.removeAttribute('hidden'); }
        else { box.setAttribute('hidden',''); }
    };
    }

    // Ensure localStorage is updated every time
    (function(){
    const _toggleForecast = window.toggleForecast;
    window.toggleForecast = function(forceOpen){
        _toggleForecast?.(forceOpen);
        const box = document.getElementById('forecast-float');
        localStorage.setItem('forecast.visible', box && !box.hasAttribute('hidden') ? '1' : '0');
    };
    })();
    </script>


<script>
(async () => {
  const el = document.getElementById('whatsup-summary');
  if (!el || el.dataset.headerBound === '1') return; // one-shot guard
  el.dataset.headerBound = '1';

  const rel = 'rag_lab/output/spoton_summary.md';
  const url = new URL(rel, document.baseURI).href + '?v=' + Date.now(); // cache-bust

  const fmtIssued = d =>
    d.toLocaleString('en-GB', {
      timeZone: 'UTC',
      day: '2-digit', month: 'short', year: 'numeric',
      hour: '2-digit', minute: '2-digit', hour12: false
    }).replace(',', '') + ' UTC';

  let issuedStr = '';

  try {
    const r = await fetch(url, { cache: 'no-store' });
    const lm = r.headers.get('Last-Modified');
    if (lm) issuedStr = fmtIssued(new Date(lm));
  } catch (_) {
    /* ignore fetch errors; we’ll fall back */
  }

  // Fallback: HTML build time or now
  if (!issuedStr && document.lastModified) {
    issuedStr = fmtIssued(new Date(document.lastModified));
  }
  if (!issuedStr) issuedStr = fmtIssued(new Date());

  // Ensure a header exists, but DO NOT wipe the region content
  let h = el.querySelector('.summary-header');
  if (!h) {
    h = document.createElement('div');
    h.className = 'summary-header';
    h.style.fontWeight = '700';
    h.style.marginTop = '10px';
    el.insertBefore(h, el.firstChild); // put header at the top
  }
  h.textContent = `3-day summary — issued ${issuedStr}`;
})();
</script>

<script>
  window.REGION_FORECASTS = {"Caithness": "Today in Caithness, it\u0027s a bit rough with fresh NNW winds at 30 mph and 6 ft @ 6s NW swell. The conditions are blown out, so it\u0027s best to give it a miss. Tomorrow sees a slight improvement with 4 ft @ 6s NNE swell and lighter 18 mph NNE winds, making for some workable corners like Sinclair\u0027s Bay and Sandside Bay. The day after, conditions drop again with 5 ft @ 6s N swell and fresh 35 mph NNW winds, leading to poor surf. Best: tomorrow.", "Causeway Coast": "Today on the Causeway Coast, it\u0027s looking solid with 6 ft @ 8s NNW swell and fresh 18 mph NNW winds. White Park Bay and Portballintrae are your best bets, especially during the tide windows. Tomorrow, conditions drop to 7 ft @ 8s NNW with fresh 29 mph NNW winds, making it poor for surfing. The day after stays similar with 7 ft @ 8s NNW and 25 mph N winds, still not ideal. Best: today.", "Cornwall": "Today in Cornwall, surf is small and a bit blown out with 1ft @8s SW at Penhale, but it\u2019s still workable during the mid-afternoon tide window. Tomorrow, conditions worsen with 3ft @5s NW across the coast, fresh winds making it choppy. The day after sees a similar pattern with 4ft @6s NNW, still messy due to strong winds. Best: today.", "County Clare": "Today in County Clare, surf is on the smaller side at 2 ft @ 6s, but fresh 18 mph WNW winds are making it messy across the board. Tomorrow sees a slight bump to 3 ft @ 6s, but the fresh 19 mph NW winds will keep conditions choppy. The day after drops back to 2 ft @ 6s with 17 mph N winds, still not ideal. Best: tomorrow.", "County Sligo": "Today in County Sligo, it\u0027s a solid day with 5 ft @ 8s NNW swell and light 10 mph NNW winds. Dunmoran Strand and Easkey Right are both looking good, especially during their best tide windows. Tomorrow, expect a bump to 7 ft @ 9s N with fresh 17 mph NNE winds, so it might be a bit choppy. The day after, conditions worsen with 24 mph N winds making it poor across the board. Best: today.", "Dingle Peninsula": "Dingle Peninsula is looking good today with clean 2 ft @9s WNW swell and light 6 mph W winds. Ballybunion Right and Ballybunion Beach are your best bets, especially during their tide windows. Tomorrow, conditions drop with 6 ft @9s NNW swell and fresh 20 mph NNW winds making it blown out. The day after continues the trend with 5 ft @8s N swell and 22 mph NNE winds, keeping it poor across the board. Best: today.", "Donegal": "Today in Donegal, it\u0027s a fun day with 3 ft @6s NW swell and light 9 mph NNW winds. Good spots like Rossnowlagh and Tullan Strand are clean and working well. Tomorrow, conditions drop to 2 ft @6s WNW with light 6 mph NW winds, still offering some playful waves at the same spots. Day after, expect a significant swell increase to 8 ft @9s N, but fresh 29 mph winds will make it blown out. Best: today.", "Gower": "Today, Gower is seeing 2 ft @ 6s W with fresh 23 mph WNW wind, making it blown out and messy across the board. Tomorrow, conditions worsen with similar 2 ft @ 5s W swell but stronger 31 mph WNW winds, keeping it poor. On the day after, the swell drops to 2 ft @ 5s NW with lighter 7 mph NNW winds, but it remains uninviting. Best: today.", "Hebrides": "Today, the Hebrides are facing a challenging surf day with 10 ft @10s NNW swell and fresh 30 mph NNW winds, making it blown out across all spots. Tomorrow, conditions worsen with similar 10 ft @10s N swell but increasing winds at 39 mph NNW, keeping it messy. On the day after, the swell drops slightly to 8 ft @9s N with still strong 32 mph N winds, resulting in poor conditions. Best: none.", "Moray": "Today in Moray, it\u0027s a bit rough with 6 ft @7s NNW swell and fresh 31 mph NW wind, making it blown out and not producing. Tomorrow, the swell remains at 6 ft @8s N but shifts to a fresh 27 mph ENE wind, keeping conditions poor. The day after sees a slight increase to 7 ft @7s N with 24 mph N wind, still not ideal. Best: none.", "North Devon": "Today in North Devon, it\u0027s a bit of a struggle with 2 ft @5s WNW swell and fresh 23 mph WNW winds making it blown out. Tomorrow sees a slight bump to 3 ft @5s NW, but the wind remains fresh at 19 mph, keeping conditions poor. Day after also holds at 3 ft @5s NNW with similar wind conditions. Best: tomorrow.", "North Yorks": "Today, North Yorks is seeing 3 ft @7s NNW with fresh 20 mph WNW winds; it\u2019s a bit blown out, so best to give it a miss. Tomorrow, the swell increases to 7 ft @10s N but with strong 33 mph WNW winds, making it messy and challenging. The day after, expect 9 ft @9s N with 25 mph NW winds, still not ideal for clean surf. Best: none.", "Northwest Wales": "Today in Northwest Wales, it\u0027s a bit of a struggle with 3 ft @5s WNW swell and fresh 20 mph WNW winds creating a blown-out scene. Tomorrow sees a slight improvement with 4 ft @6s NW swell, but the fresh 19 mph NNW wind will still keep things messy. Day after, Porth Oer lights up with 4 ft @5s NW and lighter 11 mph N winds, offering a cleaner ride. Best: day after.", "Pembrokeshire": "Today in Pembrokeshire, it\u0027s a bit of a bummer with 2 ft @5s WNW swell and fresh 16 mph WNW winds making it blown out. Tomorrow sees a slight increase to 3 ft @5s WNW, but the fresh 19 mph NW winds will keep it messy. The day after also holds 3 ft @5s NW with 18 mph NNW winds, so expect similar conditions. Best: today.", "South Devon": "Today in South Devon, surf is small at 1 ft @6s with fresh 16 mph WNW wind, making it blown out and not producing. Tomorrow sees similar conditions with 1 ft @5s, still not workable due to 14 mph NW wind. Day after, we get a slight bump to 2 ft @7s with lighter 5 mph NW wind, offering a better chance for some fun waves. Best: day after.", "Sutherland": "Today in Sutherland, it\u0027s a no-go with poor conditions: 11 ft @ 10s NNW swell and fresh 35 mph NNW winds making it blown out. Tomorrow, similar story with 11 ft @ 11s N swell and 23 mph NNE winds, still not producing. Day after, conditions drop slightly to 9 ft @ 10s N with 37 mph N winds, keeping it messy. Best: none.", "The East Coast": "Today on the East Coast, it\u0027s a bit of a struggle with 3 ft @5s NW swell and fresh 24 mph NW winds making it blown out. Tomorrow, conditions remain similar with 3 ft @9s NNE swell but winds slightly easing to 22 mph NNW, still not ideal. Day after, the swell drops to 3 ft @6s NNE with 23 mph NW winds, keeping it choppy. Best: tomorrow.", "The North East": "Today, the North East is experiencing poor conditions with 2 ft @7s NNW swell and fresh 28 mph WNW winds across all spots. Tomorrow, things improve significantly with a solid 7 ft @10s N swell and moderate 16 mph WNW winds, making for some fun surf at places like Saltburn Beach and Redcar. The day after, conditions drop back to 6 ft @8s N with fresh 32 mph NW winds, leading to blown-out surf. Best: tomorrow.", "The South": "Today, Strand is the standout with 2 ft @7s S and fresh 17 mph WNW winds. It\u0027s a bit choppy, but still workable, especially on the push. Tomorrow, conditions drop to 1 ft @5s SSW, making it a quiet day across the coast. By the day after, we see similar 1 ft @7s SW, with light winds, but not much to get excited about. Best: today.", "The West Coast": "Today on the West Coast, conditions are poor with a consistent 6 ft @ 7s NW swell but fresh 25 mph NNW winds making it blown out. Tomorrow remains similar with the same swell size and direction, but winds ease slightly to 21 mph N, still not producing anything worthwhile. On the day after, the swell holds at 6 ft @ 7s NW with winds dropping to 15 mph N, offering a better chance for some workable waves, especially during the tide windows. Best: day after."};
</script>

<script>
(() => {
  const hudTitleEl = document.getElementById('hud-title');
  const whatsupEl  = document.getElementById('whatsup-summary');

  const RF = window.REGION_FORECASTS || {};
  const RF_KEYS = Object.keys(RF);

  // Use the injected map if present; otherwise build one quickly.
  const KEY_BY_LC = window.REGION_KEY_BY_LC || Object.fromEntries(
    RF_KEYS.map(k => [k.toLowerCase(), k])
  );

  // Small normalizer so “Gower Peninsula” still hits “Gower”, etc.
  function scrub(s) {
    return String(s || '')
      .toLowerCase()
      .replace(/\b(peninsula|region|area)\b/g, '')  // drop common suffixes
      .replace(/[^\p{Letter}\p{Number}\s]/gu, '')   // strip punctuation
      .replace(/\s+/g, ' ')
      .trim();
  }

    function clearForecastText() {
    const sum = document.getElementById('whatsup-summary');
    if (sum) sum.textContent = '';

    const head = document.getElementById('forecast-header');
    if (head) head.textContent = '';

    ['panel-0','panel-1','panel-2'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.textContent = '';
    });
    }





  function resolveAreaKey(requested) {
    if (!RF_KEYS.length) return 'Cornwall';                 // hard fallback
    if (!requested) return RF_KEYS[0];

    const wantRaw = String(requested).trim();
    const wantLc  = wantRaw.toLowerCase();
    const wantScr = scrub(wantRaw);

    // 1) Exact (case-sensitive) or case-insensitive
    if (RF[wantRaw]) return wantRaw;
    if (KEY_BY_LC[wantLc]) return KEY_BY_LC[wantLc];

    // 2) Scrubbed exact against scrubbed keys
    const scrubMap = Object.fromEntries(RF_KEYS.map(k => [scrub(k), k]));
    if (scrubMap[wantScr]) return scrubMap[wantScr];

    // 3) Contains (case-insensitive) — “south wales” → “Wales”
    const ciHit = RF_KEYS.find(k => k.toLowerCase().includes(wantLc));
    if (ciHit) return ciHit;

    // 4) Contains (scrubbed) — “gower peninsula” → “Gower”
    const scrHit = RF_KEYS.find(k => scrub(k).includes(wantScr));
    if (scrHit) return scrHit;

    // 5) Last resort: first key
    return RF_KEYS[0];
  }

  function setHudTitle(text){
    if (hudTitleEl) hudTitleEl.textContent = text || '—';
  }

    function renderRegionForecast(areaName){
    if (!whatsupEl) return;

    const key = resolveAreaKey(areaName);
    const raw = (RF[key] || '').trim();

    // Ensure we have a dedicated container for the region text (separate from the header)
    let regionEl = whatsupEl.querySelector('.region-forecast');
    if (!regionEl) {
        regionEl = document.createElement('div');
        regionEl.className = 'region-forecast';
        // If a summary header exists, insert after it; otherwise append at the end
        const header = whatsupEl.querySelector('.summary-header');
        if (header && header.parentNode) {
        header.parentNode.insertBefore(regionEl, header.nextSibling);
        } else {
        whatsupEl.appendChild(regionEl);
        }
    }

    if (!raw) {
        console.warn('[hud] No REGION_FORECASTS entry for', areaName, '→ resolved:', key, 'keys=', RF_KEYS);
        regionEl.textContent = '';
        return;
    }

    // Compact / truncate like before
    let txt = raw.replace(/\n{3,}/g, '\n\n').trim();
    const cutAt = txt.search(/\n\s*(Top picks|Overview|Sub-areas)\b/i);
    if (cutAt > 100 && cutAt < 800) txt = txt.slice(0, cutAt).trim();

    regionEl.textContent = txt;

    // When restoring area (not hovering), show the resolved area name in the title
    if (!document.body.classList.contains('hud-hovering')) {
        setHudTitle(key);
    }
    }

  let lastActiveArea = RF_KEYS[0] || 'Cornwall';

// --- helpers ---------------------------------------------------------------
function getCountryCodeForArea(areaLabel) {
  const BA = window.BOUNDARIES?.by_area || {};
  const key = String(areaLabel || '').trim().toLowerCase();
  const hit = Object.values(BA).find(r => String(r.area || '').trim().toLowerCase() === key);
  return hit?.country_code ? String(hit.country_code).toUpperCase() : null;
}
function setDropdownsSilent(countryCode, areaLabel) {
  const countryEl = document.getElementById('sel-country') || document.getElementById('sel-region');
  const areaEl    = document.getElementById('sel-area');
  const nav       = window.NAV || {};
  if (!countryEl || !areaEl || !countryCode) return;

  // set country, repop areas (no events)
  countryEl.value = countryCode;
  const areas = (nav.byCountry && nav.byCountry[countryCode]) ? nav.byCountry[countryCode] : [];
  areaEl.innerHTML = '';
  areaEl.add(new Option('All', 'ALL'));
  for (const a of areas) areaEl.add(new Option(a.name, String(a.id)));

  if (areaLabel) {
    const opts = Array.from(areaEl.options);
    const byLabel = opts.find(o => o.text.trim().toLowerCase() === String(areaLabel).trim().toLowerCase());
    areaEl.value = byLabel?.value || 'ALL';
  } else {
    areaEl.value = 'ALL';
  }
}
function setHudFromPayload(p) {
  if (p.spot_name && typeof setHudTitle === 'function') setHudTitle(p.spot_name);
  if (p.area && typeof renderRegionForecast === 'function') {
    if (typeof setAreaChip === 'function') setAreaChip(p.area); // optional
    renderRegionForecast(p.area);
  }
}

// --- state -----------------------------------------------------------------
let lockedArea = null;     // last clicked area (truthy), used to revert after hover
let lockedCountry = null;  // last clicked country code

// --- Bridge messages from the map iframe -----------------------------------
window.addEventListener('message', (evt) => {
  const d = evt.data || {};

  // Optional: if you still emit activeArea, treat it like a soft lock
  if (d.type === 'activeArea') {
    if (d.area) {
      lockedArea = d.area;
      renderRegionForecast(lockedArea);
    }
    return;
  }

  // HOVER = preview ONLY IF area is present — otherwise do nothing
  if (d.type === 'spotHover') {
    const p = d.payload || {};
    document.body.classList.add('hud-hovering');
    if (p.area) setHudFromPayload(p);   // <- prevents Caithness fallback
    return;
  }

  // UNHOVER = revert to the last locked click (if any)
  if (d.type === 'spotUnhover') {
    document.body.classList.remove('hud-hovering');
    if (lockedArea) renderRegionForecast(lockedArea); // don’t call with undefined
    return;
  }

  // CLICK = lock HUD + dropdowns + persistence
  if (d.type === 'spotClick') {
    const p = d.payload || {};

    // Derive country if missing
    if (!p.country_code && p.area) p.country_code = getCountryCodeForArea(p.area);

    // Lock state (only if we actually have an area)
    if (p.area) lockedArea = p.area;
    if (p.country_code) lockedCountry = p.country_code;

    // Update HUD now (only if area present)
    setHudFromPayload(p);

    // Sync dropdowns silently if we know the country
    if (p.country_code) setDropdownsSilent(p.country_code, p.area || null);

    // Persist only if we have a country (to avoid writing junk)
    try {
      if (p.country_code) {
        localStorage.setItem('navSelection_v1', JSON.stringify({
          country: p.country_code,
          area:    p.area || 'ALL'
        }));
      }
    } catch(_) {}

    return;
  }

  // If iframe posts navSync on click, keep it display-only
  if (d.type === 'navSync') {
    const { country_code, area } = d.payload || {};
    if (country_code) setDropdownsSilent(country_code, area || null);
    return;
  }
});

  // First paint
  renderRegionForecast(lastActiveArea);
})();
</script>



<script>
(function runNavFromTemplateOnce(){
  const el = document.getElementById('nav-code');
  if (!el) return;
  if (window.__navCodeBooted) return;       // avoid double-execution
  window.__navCodeBooted = true;

  const s = document.createElement('script');
  s.type = 'text/javascript';
  s.text = el.textContent || el.innerText || '';
  document.head.appendChild(s);

  console.log('[nav] bootstrap executed');
})();
</script>


<script>
  // --- Gale chip colour updater ---
  async function updateGalesChipState() {
    const btn = document.getElementById('synoptic-toggle');
    if (!btn) return;

    try {
      const url = 'https://raw.githubusercontent.com/Bryan701701/spoton-synoptic/main/synoptic/shipping_forecast_latest.json';
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error('fetch failed');
      const j = await r.json();

      const areas = j.areas || {};
      const hasGales = Object.values(areas).some(a => {
        const t = (a.gale_warning || a.gale || '').trim();
        return t && !/^\s*(no|nil)\s+gales?\b|no\s+gale\s+warnings?/i.test(t);
      });

      if (hasGales) {
        btn.style.background = '#f8caca';
        btn.style.color = '#8b1a1d';
        btn.style.borderColor = '#f2c8cc';
      } else {
        btn.style.background = '#eefcff';
        btn.style.color = '#004f63';
        btn.style.borderColor = '#c8f2f9';
      }

      btn.textContent = 'Gales ▾';
    } catch (err) {
      console.warn('[GalesChip] update failed', err);
    }
  }

  // Run once when page finishes loading
  window.addEventListener('load', updateGalesChipState);

  // Optional: refresh whenever you refocus the tab
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') updateGalesChipState();
  });
</script>



<script>
(function () {
  const wrap      = document.getElementById('area-nav');
  const countryEl = document.getElementById('sel-country') || document.getElementById('sel-region');
  const areaEl    = document.getElementById('sel-area');
  const iframe    = document.getElementById('tv-map');

  if (!window.NAV || !countryEl || !areaEl || !iframe) {
    if (wrap) wrap.hidden = true;
    return;
  }

  const nav = window.NAV;
  const STORAGE_KEY = 'navSelection_v1';
  let mapIsReady = false;       // flip to true when iframe posts "mapReady"
  let didInitialSync = false;   // ensure we only do first sync once

  function setOptions(sel, items, placeholder, selectValue) {
    sel.innerHTML = '';
    if (placeholder) sel.add(new Option(placeholder, ''));
    for (const it of items) {
      const opt = new Option(it.label, it.value);
      if (it.disabled) opt.disabled = true;
      sel.add(opt);
    }
    if (selectValue !== undefined) sel.value = selectValue;
    sel.disabled = sel.options.length === 0 || (sel.options.length === 1 && sel.options[0].value === '');
  }

  function postNav(payload) {
    iframe.contentWindow?.postMessage({ type: 'navGo', payload }, '*');
  }

  // Build Country list: NE Atlantic first, then all countries from NAV
  const NEA = {
    value: 'NEA',
    label: (nav.region && nav.region.name) || 'NE Atlantic'
  };
  const countries = [NEA].concat(
    (nav.countries || []).map(c => ({ value: c.code, label: c.name }))
  );

  // Populate Country now (placeholder stays until we do initial sync)
  setOptions(countryEl, countries, 'Region / Country');

  function populateAreas(cc, selectVal = 'ALL') {
    if (cc === 'NEA') {
      setOptions(areaEl, [], null);
      areaEl.disabled = true;
      return;
    }
    const areas = (nav.byCountry && nav.byCountry[cc]) ? nav.byCountry[cc] : [];
    const items = [{ value: 'ALL', label: 'All' }].concat(
      areas.map(a => ({ value: String(a.id), label: a.name }))
    );
    setOptions(areaEl, items, null, selectVal);
    areaEl.disabled = items.length === 0;
  }

  function saveSelection() {
    const state = { country: countryEl.value || '', area: areaEl.value || '' };
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (_) {}
  }

  function readSelection() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const s = JSON.parse(raw);
      if (!s || typeof s !== 'object') return null;
      return s;
    } catch (_) { return null; }
  }

  // React to changes
  countryEl.addEventListener('change', () => {
    const cc = countryEl.value;
    if (cc === 'NEA') {
      populateAreas('NEA');
      // Zoom to NEA bbox if present; otherwise fall back to continent code if you want
      const bbox = nav.region && Array.isArray(nav.region.bbox) ? nav.region.bbox : null;
      if (bbox) postNav({ bbox });
      else       postNav({ country: 'GB' }); // harmless fallback so something is visible
      saveSelection();
      return;
    }
    populateAreas(cc, 'ALL');
    postNav({ country: cc });
    saveSelection();
  });

  areaEl.addEventListener('change', () => {
    const cc = countryEl.value;
    const val = areaEl.value;
    if (!cc || cc === 'NEA' || !val || val === 'ALL') {
      postNav({ country: cc });
      saveSelection();
      return;
    }
    const hit = (nav.byCountry && nav.byCountry[cc] || []).find(a => String(a.id) === val);
    if (hit && Array.isArray(hit.bbox)) postNav({ bbox: hit.bbox });
    else if (hit && hit.name)          postNav({ area: hit.name, country: cc });
    else                               postNav({ country: cc });
    saveSelection();
  });

  // Perform the initial sync only after the map says it's ready,
  // so the first navGo always wins and both UI + map match.
  function doInitialSync() {
    if (didInitialSync) return;
    if (!mapIsReady) return;

    const saved = readSelection();
    if (saved && saved.country) {
      // restore saved selection
      countryEl.value = saved.country;
      // if country no longer exists (edge-case), default to NEA
      if (countryEl.value !== saved.country) countryEl.value = 'NEA';
    } else {
      // default to NEA
      countryEl.value = 'NEA';
    }
    countryEl.dispatchEvent(new Event('change'));

    // If we restored an area
    if (saved && saved.area && saved.country && saved.country !== 'NEA') {
      // Populate first (change already did that), then set + fire
      areaEl.value = saved.area;
      if (areaEl.value === saved.area) {
        areaEl.dispatchEvent(new Event('change'));
      }
    }

    didInitialSync = true;
  }

  // Wait for iframe to be ready
  window.addEventListener('message', (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'mapReady') {
      mapIsReady = true;
      doInitialSync();
    }
  });


  // Respond to double-click reset from the map iframe
  window.addEventListener('message', (ev) => {
    const msg = ev.data || {};
    if (msg.type !== 'mapResetNEA') return;

    // 1) Set dropdown to NE Atlantic (pseudo-country)
    countryEl.value = 'NEA';
    populateAreas('NEA');            // NEA has no areas; this will disable areaEl

    // 2) Fit NEA bbox (fallback to EU if missing)
    const bbox = Array.isArray(nav?.region?.bbox) ? nav.region.bbox : null;
    postNav(bbox ? { bbox } : { cont: 'EU' });

    // 3) Keep summary/HUD aligned
    try {
      window.lastActiveArea = 'NE Atlantic';
      renderRegionForecast('NE Atlantic');
    } catch (_) {}

    // 4) Persist selection
    saveSelection();
  });





  // Fallback: if iframe 'load' fires but we miss mapReady (shouldn’t happen), sync anyway after a short delay
  iframe.addEventListener('load', () => setTimeout(doInitialSync, 500));
})();
</script>
<script>
(function() {
  try {
    const w = window.innerWidth || document.documentElement.clientWidth || 0;
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const currentPath = location.pathname;


    const isDesktop = /spot_on_tv_modern\.html$/i.test(currentPath) || /\/(index\.html)?$/i.test(currentPath);

    if (w < 700 && isTouch && isDesktop) {
      const mobileURL = location.origin + '/spot_on_mobile.html';
      console.log("[SPOT:ON] redirecting to mobile view:", mobileURL);
      location.href = mobileURL;
    }
  } catch (err) {
    console.warn("Mobile redirect check failed:", err);
  }
})();
</script>
</body>
</html>